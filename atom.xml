<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SailHe&#39;s Cyber Memory(Core)</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sailhe.github.io/"/>
  <updated>2024-02-20T01:38:29.886Z</updated>
  <id>https://sailhe.github.io/</id>
  
  <author>
    <name>SailHe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>离散之心与情感轮</title>
    <link href="https://sailhe.github.io/2024/02/19/%E7%A6%BB%E6%95%A3%E4%B9%8B%E5%BF%83%E4%B8%8E%E6%83%85%E6%84%9F%E8%BD%AE/"/>
    <id>https://sailhe.github.io/2024/02/19/离散之心与情感轮/</id>
    <published>2024-02-19T09:28:00.000Z</published>
    <updated>2024-02-20T01:38:29.886Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2024/02/18/Discrete_Heart-离散之心">Discrete_Heart-离散之心</a></p><blockquote><p>商店页面已经开放, 可添加<strong>愿望单</strong>.</p><p><a href="https://store.steampowered.com/app/2617300?utm_source=sailhe.github.io" target="_blank" rel="noopener">Steam 上的 离散之心</a></p></blockquote><ul><li>“所有的感知都带有情感色彩。”  ——伊曼纽尔·康德</li><li>“人类行为来自三个主要来源：欲望、情感和知识。”  -柏拉图</li></ul><p>心理学家欧文·亚隆认为: 生活中的大部分焦虑和痛苦，其实都来源于对死亡的恐惧。<br>因此, 本游戏实际上也有一种愿景是希望玩家通过增加自身对情感的把控, 减少生活中的焦虑与痛苦,<br>众所周知死亡是不可避免的, 但恐惧做为一种情绪是可以加以控制的, 而方式就是情感轮这一情绪理论.<br>因此, 我们实际上希望玩家通过玩离散之心这款游戏达到”散心”,”放松心情”的目的,</p><h2 id="情感轮"><a href="#情感轮" class="headerlink" title="情感轮"></a>情感轮</h2><p><img src="/assets/2024-02-19-18-24-07.png" alt="情感轮"></p><p>Robert Plutchik/罗伯特·普拉奇克(1927 年 10 月 21 日 - 2006 年 4 月 29 日)创造了一个情绪轮来说明不同的情绪。 Plutchik 于 1980 年首次提出他的锥形模型 (3D) 或轮子模型 (2D) 来描述情绪如何相关。</p><h2 id="离散之心中的情感轮"><a href="#离散之心中的情感轮" class="headerlink" title="离散之心中的情感轮"></a>离散之心中的情感轮</h2><p>大致玩法</p><ol><li>不同情感会带来不同的属性增益与减益(出于平衡既有增益也有减益)</li><li>增加了名为”移情物”的道具, 这种道具会消耗情感指示物(一点情感对应一个情感指示物).</li><li>某些任务可能会依赖于特定的移情物(离开游戏或者说通关也被设计为是这样)</li><li>某些行为会对情感产生影响, 譬如战斗行为会增加愤怒(愤怒本身会增加伤害).</li><li>等等</li></ol><p><img src="/assets/2024-02-19-21-31-47.png" alt="0.7.6.16a"></p><p>上图的右侧便是情感轮在游戏中的实际表示.<br>它是不断转动的, 这用于模拟情感的变化, 然后带来不同的影响.<br>并且, 游戏中的所有NPC都会在后台运行同一套逻辑.</p>]]></content>
    
    <summary type="html">
    
      离散之心的情感构筑核心玩法, 灵感来自普拉齐克情感轮(Plutchik-wheel), 本文将大致介绍两者之间的联系.
    
    </summary>
    
      <category term="GameDevelop" scheme="https://sailhe.github.io/categories/GameDevelop/"/>
    
    
      <category term="aRPG" scheme="https://sailhe.github.io/tags/aRPG/"/>
    
      <category term="心理学" scheme="https://sailhe.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="Steam" scheme="https://sailhe.github.io/tags/Steam/"/>
    
  </entry>
  
  <entry>
    <title>Discrete_Heart-离散之心</title>
    <link href="https://sailhe.github.io/2024/02/18/Discrete_Heart-%E7%A6%BB%E6%95%A3%E4%B9%8B%E5%BF%83/"/>
    <id>https://sailhe.github.io/2024/02/18/Discrete_Heart-离散之心/</id>
    <published>2024-02-18T09:28:00.000Z</published>
    <updated>2024-02-19T14:05:28.462Z</updated>
    
    <content type="html"><![CDATA[<p>商店页面已经开放, 可添加<strong>愿望单</strong>.</p><p><a href="https://store.steampowered.com/app/2617300?utm_source=sailhe.github.io" target="_blank" rel="noopener">Steam 上的 离散之心</a></p><p>下面是商店页面的主要内容(截止<code>2024-02-19</code>)</p><h2 id="商店内容"><a href="#商店内容" class="headerlink" title="商店内容"></a>商店内容</h2><h3 id="关于这款游戏"><a href="#关于这款游戏" class="headerlink" title="关于这款游戏"></a>关于这款游戏</h3><p>离散之心是一款俯视角2D像素风格的情感构筑类游戏. 喜悦,信任,害怕…每种初始情感对应不同初始属性与道具,玩家”注入”并操控游戏角色, 构筑8种基础情感, 寻找名为”无心”的答案.</p><h3 id="背景设定"><a href="#背景设定" class="headerlink" title="背景设定:"></a>背景设定:</h3><p>从前车马很慢, 书信很远, 鸽子连接思念的两端, 象征”爱与和平”;<br>现在机械喧嚣, 人潮拥挤, 信息膨胀, 放鸽子象征着”背叛与纷争”.<br>在某个赛博朋克的未来世界时间线下, 秩序分崩离析的社会上有越来越多的人必须用更快的速度正确理解并处理遭遇的情感:<br>餐厅服务员错误捕获了客人的心情, 办公室职员未能及时体会领导的心思, 他们丢掉了工作…<br>自己生活尚未安顿就贪图享乐未婚先孕, 无人照顾的后代, 被战争波及的人们, 他们的情感, 他们的未来又该何去何从?<br>翘首以盼, AlphaMood开发出了第一代离散之心情感模组, 该模组的其中一个重大功能是通过模拟意识训练参与者对模块的适配度, 现在这项测试活动正招募志愿者.<br>“一切都变得更快, 情感也需要如此”, 一位匿名人士如此评价道, “植入电子情感芯片势在必行”.<br>于是一个又一个情感麻木的角色, 被生活磋磨得心如死灰的ta们正打算参与情感模组训练, 成为那个更懂”散心”的”无心者”, 一切烦恼都将烟消云散.<br>离成为那个最懂打工不用吃喝拉撒的极品工具人又近了一步, “这只是AlphaMood的一小步, 却是所有打工人的一大步”, AlphaMood的CEO在发布会上如此说道.</p><h3 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标:"></a>主要目标:</h3><p>上面那些都不是玩家要关心的, 玩家只需要完成游戏就行了.<br>每局游戏的主要目标是在限制的时间指数(一个用于模拟现实时间的数值)内从数个随机生成的副地图种找到随机分布的8个基础移情物并成为”无心者”, 回到主地图将之交给”向导”即可完成一局游戏.</p><h3 id="主要特色"><a href="#主要特色" class="headerlink" title="主要特色:"></a>主要特色:</h3><ul><li>情感构筑核心玩法, 该玩法灵感来自普拉齐克情感轮(Plutchik-wheel)  <ol><li>还原了情感轮理论主要内容, 包括基础情感,组合情感等.  </li><li>情感被设定为能增益或减益各项能力, 得到移情配方之后可以通过移情自行调整这种组合.  </li><li>需要根据遭遇的情况自行决定应该获得或者保留哪些情感, 以及…偶尔也可能会遭遇一点儿意外打破你的计划.  </li><li>向导只会认可”无心者”完成游戏.  </li></ol></li><li>没有太多系统层面的限制, 玩家并不是一定要扮演某个主角以某种形式拯救世界, 您可以刻意扮演某个角色, 取决于您自己。  </li><li>与NPC互动, 剧情包含解谜要素, 各种剧情之间可能存在联系但也并不是一定要联系.  </li><li>经过简化的ARPG战斗系统: 没有花哨的技能与魔法系统, 有数种冷兵器可以做为战斗武器.  </li><li>轻度ROGUE: 经过裁剪的RogueLike机制  <ol><li>玩家将在视野受限的地图中展开活动.  </li><li>随机生成的副地图(一局游戏会生成一次, 在不同副地图会有地形与更大可能性遇见特定类型的单位).  </li><li>随机属性点奖励.  </li><li>在副地图中遭遇随机生成的单位, 并对可能发生的剧情进行选择.  </li><li>包括玩家在内所有单位可以拾取物品, 有独立存档并且会永久死亡  </li></ol></li><li>交易系统: 可以与大多数NPC进行交易, 使用货币换取他们手中你想要的物品.  </li><li>合成系统: 获得配方之后可以合成物品  </li><li>自由决定所有NPC的生死, 没有剧情限制的战斗.  </li><li>所有单位有主动触发战斗的可能性(所有单位是无阵营的)  </li><li>所有单位随机生成并跟随玩家控制角色的成长而成长  </li><li>熟悉之后一局游戏时间可以控制在30min以内, 适合碎片时间.</li></ul><p>希望您玩得开心, 生活愉快!<br>最重要的是: 心情不好的时候记得”散心”.</p><p><img src="https://media.st.dl.eccdnx.com/steam/apps/2617300/extras/GIF_2023-12-11_20-36-44_%E6%B4%9E%E7%A9%B4%E4%B8%AD%E7%9F%B3%E7%8B%AE%E5%AD%90%E5%85%89%E5%BD%B1%E6%95%88%E6%9E%9C_all_lan.gif?t=1708252396" alt></p>]]></content>
    
    <summary type="html">
    
      离散之心是一款俯视角2D像素风格的情感构筑类游戏. 喜悦,信任,害怕...每种初始情感对应不同初始属性与道具,玩家&quot;注入&quot;并操控游戏角色, 构筑8种基础情感, 寻找名为&quot;无心&quot;的答案.
    
    </summary>
    
      <category term="GameDevelop" scheme="https://sailhe.github.io/categories/GameDevelop/"/>
    
    
      <category term="aRPG" scheme="https://sailhe.github.io/tags/aRPG/"/>
    
      <category term="心理学" scheme="https://sailhe.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="Steam" scheme="https://sailhe.github.io/tags/Steam/"/>
    
  </entry>
  
  <entry>
    <title>STL_vector_benchmarking</title>
    <link href="https://sailhe.github.io/2022/12/25/STL_vector_benchmarking/"/>
    <id>https://sailhe.github.io/2022/12/25/STL_vector_benchmarking/</id>
    <published>2022-12-25T14:25:00.000Z</published>
    <updated>2024-02-19T06:16:25.860Z</updated>
    
    <content type="html"><![CDATA[<p><code>2022-12-25 22:25</code><br>PS: 这是大约一年之前在另一台计算机上做的一个基准测试了,<br>当时需要优化一个网络文件上传程序, 而那里面大量使用了vector, 而且有大量深拷贝,<br>因此对这部分进行了基准测试, 并针对性进行了优化.<br>若在你的计算机上跑出来结果不一致, 这是正常的, 但通常结论不会有偏差.<br>细节请看源码<br>关于<code>std::vector</code>的深拷贝基准测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::vector&lt;std::uint32_t&gt; responseRawBytes = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; // 10Byte*10000</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="keyword">uint32_t</span>&gt; responseRawBytes; <span class="comment">// 1024Byte*10000</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        responseRawBytes.push_back(i % UINT8_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::steady_clock&gt; beginTime = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt; 10000; ++i) &#123; // 10Byte*10000</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123; <span class="comment">// 1024Byte*10000</span></span><br><span class="line">        <span class="comment">// 10Byte*10000 Debug  : 91 92 92 92 93 ms</span></span><br><span class="line">        <span class="comment">// 10Byte*10000 Release: 09 09 09 10 09 ms</span></span><br><span class="line">        <span class="comment">// 1024Byte*10000 Debug: 2647 2658 2652 2646 2653 ms</span></span><br><span class="line">        <span class="comment">// 1024Byte*10000 Release: 36 37 36 37 36 ms</span></span><br><span class="line">        <span class="comment">//std::vector&lt;std::int32_t&gt; responseBytes;</span></span><br><span class="line">        <span class="comment">//std::transform(responseRawBytes.begin(), responseRawBytes.end(), std::back_inserter(responseBytes), [](const std::uint32_t &amp;byte) &#123;</span></span><br><span class="line">        <span class="comment">//    return static_cast&lt;std::int32_t&gt;(byte);</span></span><br><span class="line">        <span class="comment">//&#125;);</span></span><br><span class="line">        <span class="comment">// 1024Byte*10000 Debug: 4979 4932 4936 4935 4930 ms</span></span><br><span class="line">        <span class="comment">// 1024Byte*10000 Release: 35 32 31 31 32 ms</span></span><br><span class="line">        <span class="comment">//std::vector&lt;std::int32_t&gt; responseBytes;</span></span><br><span class="line">        <span class="comment">//for (auto iter = responseRawBytes.begin(); iter != responseRawBytes.end(); ++iter) &#123;</span></span><br><span class="line">        <span class="comment">//    responseBytes.push_back(static_cast&lt;std::int32_t&gt;(*iter));</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">// 10Byte*10000 Debug  : 16 16 16 16 16 ms</span></span><br><span class="line">        <span class="comment">// 10Byte*10000 Release: 00 00 00 01 00 ms</span></span><br><span class="line">        <span class="comment">// 1024Byte*10000 Debug  : 17 17 17 17 17 ms</span></span><br><span class="line">        <span class="comment">// 1024Byte*10000 Release: 01 01 01 01 01 ms</span></span><br><span class="line">        <span class="comment">//auto rawBytesPtr = reinterpret_cast&lt;std::int32_t*&gt;(&amp;responseRawBytes[0]);</span></span><br><span class="line">        <span class="comment">//std::vector&lt;std::int32_t&gt; responseBytes(rawBytesPtr, rawBytesPtr + responseRawBytes.size());</span></span><br><span class="line">        <span class="comment">// 10Byte*10000 Debug  : 18 17 20 18 17 ms</span></span><br><span class="line">        <span class="comment">// 10Byte*10000 Release: 00 00 00 01 00  ms</span></span><br><span class="line">        <span class="comment">// 1024Byte*10000 Debug  : 19 19 19 19 19 ms</span></span><br><span class="line">        <span class="comment">// 1024Byte*10000 Release: 01 01 01 01 01 ms</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="keyword">int32_t</span>&gt; responseBytes(responseRawBytes.begin(), responseRawBytes.end());</span><br><span class="line">        <span class="comment">// 1024Byte*10000 Debug  : 22 22 22 22 23 ms</span></span><br><span class="line">        <span class="comment">// 1024Byte*10000 Release: 01 01 01 01 01 ms</span></span><br><span class="line">        <span class="comment">//std::vector&lt;std::int32_t&gt; responseBytes;</span></span><br><span class="line">        <span class="comment">//responseBytes.assign(responseRawBytes.begin(), responseRawBytes.end());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::steady_clock&gt; endTime = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="keyword">auto</span> diffTimeMs = <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;(endTime - beginTime);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Delta Time: "</span> &lt;&lt; diffTimeMs.count() &lt;&lt; <span class="string">" ms"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论表明，裸指针方式效率最高，但是考虑到安全性，最后还是折衷使用构造器方式最合适，因为两者相差其实也就1到2ms.<br>若可以做到不拷贝的话，效率就更好看了。</p><p><strong>效率和通用性(抽象性)</strong>大概需要一直对它们进行平衡</p><p>最终效果还是不错的。</p>]]></content>
    
    <summary type="html">
    
      stl::vector的基准测试
    
    </summary>
    
      <category term="Induction" scheme="https://sailhe.github.io/categories/Induction/"/>
    
    
      <category term="STL" scheme="https://sailhe.github.io/tags/STL/"/>
    
      <category term="标准库" scheme="https://sailhe.github.io/tags/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关于FireFox与Chrome浏览器的日常使用</title>
    <link href="https://sailhe.github.io/2019/07/05/%E5%85%B3%E4%BA%8EFireFox%E4%B8%8EChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/"/>
    <id>https://sailhe.github.io/2019/07/05/关于FireFox与Chrome浏览器的日常使用/</id>
    <published>2019-07-05T14:10:32.000Z</published>
    <updated>2024-02-19T10:42:52.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你可能也需要的功能-amp-解决方案"><a href="#你可能也需要的功能-amp-解决方案" class="headerlink" title="你可能也需要的功能&amp;解决方案"></a>你可能也需要的功能&amp;解决方案</h1><p>解决方案</p><ol><li><a href="/2019/07/05/FireFox-Customize/#Tips">已存在的功能</a></li><li>附加组件</li><li>脚本</li></ol><ul><li><code>脚本</code>从Google翻译界面获取原文链接</li></ul><p>挺暴力的实现:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name Google翻译(上下文)将原链接输出至控制台</span></span><br><span class="line"><span class="comment">// @namespace Violentmonkey Scripts</span></span><br><span class="line"><span class="comment">// @match https://translate.googleusercontent.com/translate_c</span></span><br><span class="line"><span class="comment">// @requirehttps://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js</span></span><br><span class="line"><span class="comment">// @grant none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">// window.location.host</span></span><br><span class="line">  <span class="keyword">let</span> current_url = <span class="built_in">window</span>.location.href.substr(<span class="number">113</span>);</span><br><span class="line">  current_url = current_url.substr(<span class="number">0</span>, current_url.indexOf(<span class="string">"&amp;"</span>));</span><br><span class="line">  <span class="comment">// console.copy(current_url);</span></span><br><span class="line">  <span class="built_in">console</span>.clear();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"已清空"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(current_url);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><ul><li><code>脚本</code>将google搜索界面的统计链接换为直链: 已有类似实现-&gt;搜索</li><li><code>附加组件</code>站内搜索FireFox插件(或者基于支持站内搜索语法的搜索引擎)<ol><li>可使用<a href="https://github.com/SailHe/GlitterDrag" target="_blank" rel="noopener">GlitterDrag</a>实现</li></ol></li><li><code>脚本</code>匹配URL</li></ul><ol><li><p>正则表达式, 原理之类的<br><a href="https://www.cnblogs.com/cench/p/6718466.html" target="_blank" rel="noopener">js 正则匹配 域名【host】</a><br><code>SK: JS 判断是否合法URL</code><a href="https://segmentfault.com/q/1010000015105890" target="_blank" rel="noopener">求一个验证url合法性的正则，网上找了很多都有漏洞</a></p><blockquote><p><code>SK: 使用异常来做判断</code><a href="https://tech.msla.top/2017/09/11/用exception异常还是if判断/" target="_blank" rel="noopener">用Exception异常还是if判断</a><br>java规范的定义是说异常不要参与控制流程，你不能把异常作为一种正常的控制流程作为程序的一部分，这样是不对的.<br><a href="https://www.cnblogs.com/cench/p/6718466.html" target="_blank" rel="noopener">js 正则匹配 域名【host】 - cench - 博客园</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^http(s)?:\/\/(.*?)\<span class="comment">//.exec(location.href)</span></span><br><span class="line">location.href.split(<span class="regexp">/^http(s)?:\/\/(.*?)\//</span>)</span><br></pre></td></tr></table></figure></blockquote></li><li><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkURL = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> str = url;</span><br><span class="line"><span class="comment">//判断URL地址的正则表达式为:http(s)?://([\w-]+\.)+[\w-]+(/[\w- ./?%&amp;=]*)?</span></span><br><span class="line"><span class="comment">//下面的代码中应用了转义字符"\"输出一个字符"/"</span></span><br><span class="line"><span class="keyword">var</span> Expression = <span class="regexp">/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&amp;=]*)?/</span>;</span><br><span class="line"><span class="keyword">var</span> objExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(Expression);</span><br><span class="line"><span class="keyword">if</span>(objExp.test(str) == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// checkURL('index');  // false</span></span><br><span class="line"><span class="comment">// checkURL('http://www.baidu.com');  // true</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>文本管理<ol><li><a href="https://github.com/0x6b/copy-selection-as-markdown" target="_blank" rel="noopener">0x6b/copy-selection-as-markdown: Firefox add-on to copy selection as Markdown</a></li></ol></li><li>标签页管理<ol><li><a href="https://github.com/cnwangjie/better-onetab" target="_blank" rel="noopener">better-onetab</a></li></ol></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="浏览器数据"><a href="#浏览器数据" class="headerlink" title="浏览器数据"></a>浏览器数据</h2><p>清除storage:</p><p><img src="/assets/2019-07-05-FireFox-Customize/清缓存.png" alt="清除storage缓存"></p><p>清除Cookie: ctrl+f5</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>FireFox 提示此网站中某些内容(例如图像)不安全时 尝试屏蔽http传输的内容</li><li>对于http的网站 如果被重定向至 <code>貌似现在被卖了...</code><a href="https://www.139.site" target="_blank" rel="noopener">139</a> 则说明被劫持了 此时可以尝试https(一般可以访问 但可能存在内容与http不对应的情况), 或是尝试类似TOR的加密线路</li><li>简单来说有的网站http方式甚至是无法访问的(流氓式恶意重定向)</li><li>有的网站会在某个特定的时间段内对原有http的网站进行重定向Https, 现象大概就是网址变化+书签标记变化(如果存了书签的话)</li></ul><h2 id="2019-05-03-证书过期事件"><a href="#2019-05-03-证书过期事件" class="headerlink" title="2019-05-03_证书过期事件"></a>2019-05-03_证书过期事件</h2><p><code>附加组件全部失效</code><br>about:config<br>signatures.required<br><a href="http://www.dbsec.cn/zx/20190505-5.html" target="_blank" rel="noopener">Mozilla曝出大乌龙 证书过期导致全球Firefox用户无法使用扩展</a><br>可以避免附加组件的签名验证<br><a href="https://www.solidot.org/story?sid=60486" target="_blank" rel="noopener">Solidot | 如何修复 Firefox 的扩展签名过期</a><br><a href="https://www.solidot.org/story?sid=60476" target="_blank" rel="noopener">Solidot | 因中级证书过期 Firefox 扩展停止工作</a><br><a href="https://techdows.com/2019/05/firefox-add-ons-disabled-and-fail-to-install-due-to-certificate-issue.html" target="_blank" rel="noopener">Intermediate signing certificate expiry causes All Firefox add-ons to be disabled or fail to install</a><br><a href="https://blog.mozilla.org/addons/2019/05/04/update-regarding-add-ons-in-firefox/" target="_blank" rel="noopener">Add-ons disabled or failing to install in Firefox | Mozilla Add-ons Blog</a><br><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1549017" target="_blank" rel="noopener">1549017 - All extensions disabled due to expiration of intermediate signing cert (Workaround on standard builds)</a></p><p><img src="/assets/2019-07-05-FireFox-Customize/火狐.png" alt="这是谋智中国版本的火狐的首页"></p><h2 id="疑似chrome某个版本的BUG"><a href="#疑似chrome某个版本的BUG" class="headerlink" title="疑似chrome某个版本的BUG"></a>疑似chrome某个版本的BUG</h2><p>但没空去研究</p><p><img src="/assets/2019-07-05-FireFox-Customize/chrome.png" alt="chrome"></p><p><img src="/assets/2019-07-05-FireFox-Customize/firefox-chrome.png" alt="firefox-chrome"></p><p>FireFox没能找到 然后翻看了一下数据 确实没有034这一条</p>]]></content>
    
    <summary type="html">
    
      自定义FireFox
    
    </summary>
    
      <category term="Induction" scheme="https://sailhe.github.io/categories/Induction/"/>
    
    
      <category term="折腾" scheme="https://sailhe.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="Customize" scheme="https://sailhe.github.io/tags/Customize/"/>
    
  </entry>
  
  <entry>
    <title>DotNet全家桶与Oracle数据库</title>
    <link href="https://sailhe.github.io/2019/07/02/DotNet%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B8%8EOracle%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://sailhe.github.io/2019/07/02/DotNet全家桶与Oracle数据库/</id>
    <published>2019-07-02T12:45:29.000Z</published>
    <updated>2024-02-19T11:22:06.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><strong>本文是按照时间顺序记录的流水帐,未经整理</strong></li><li>流水帐的好处在于符合认知规律</li></ul><h1 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h1><p><a href="https://beansoftapp.github.io/2010/11/18/oracle%E6%95%B0%E6%8D%AE%E5%BA%9311gr2%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/" target="_blank" rel="noopener">Oracle数据库11gR2下载地址 - WebLogic Android 博客</a><br>将注册表中的服务对应的表项删除后,重启即可看到服务项被删除</p><p><a href="https://www.cnblogs.com/hoobey/p/6010804.html" target="_blank" rel="noopener">Oracle 11g安装步骤详谈 - starskyhu - 博客园</a><br><a href="https://jlhxxxx.github.io/oracle-rudiment.html" target="_blank" rel="noopener">Oracle 十全大补汤 | AMAN’s BLOG</a></p><p>执行sqlplus报错<code>SP2-0750: You may need to set ORACLE_HOME to your Oracle software directory</code>ORACLE_HOME环境变量未配置好: 需要到app…home这一级<br><code>ORA-12560: TNS: 协议适配器错误</code>未解决 重装oracle<br><a href="https://www.jianshu.com/p/3d84efb92484" target="_blank" rel="noopener">Windows下把Oracle卸载干净 - 简书</a></p><p><code>INS-13001 环境不满足最低要求</code> 忽略就行 也可参考更改配置文件(但是没看明白)<br><a href="https://ianeiu.github.io/2018/09/19/oracle%E5%BC%82%E5%B8%B8%E9%9B%86/" target="_blank" rel="noopener">Oracle——异常集 · IanEiU</a></p><p><code>OUI-10137</code>C:\Program Files\Oracle\Inventory没有删除(PS: 在这种情况下新生成的文件不用删除)<br><code>在注册表中没有找到指定的主目录名</code> 据说是没有更改环境变量 但是这里是更改了的 或许和之前没有删除OUI-10137错误的文件有关</p><p>事后可登录 <a href="https://localhost:1158/em" target="_blank" rel="noopener">Oracle Enterprise Manager</a><br>仅管理员才是可以登录到 Enterprise Manager 执行管理任务 (如设置封锁, 电子邮件通知调度) 的数据库用户。</p><p><img src="/assets/img/sharding/oracle/oracle安装成功结果.png" alt="oracle安装成功结果"></p><p>然后使用<strong>数据库管理软件</strong>连接:</p><p><strong>Toad</strong>是数据库管理及开发的极佳工具，简单的说就是oem+sqlplus+pl/sql developer</p><p><code>错误 忘了怎么解决的了</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot load OCI DLL:  DriveLetter:\app\username\product\11.2.0\instantclient_11_1\oci.dll</span><br></pre></td></tr></table></figure></p><p><code>错误 忘了怎么解决的了</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This product require Microsoft MSXML 4.20.9818.0 or above and will not be installed at this time. Please refer to the product release notes for specific requirements. Microsoft MSXML 4(msxml.msi) can be installed from the Microsoft download centre . </span><br><span class="line">Benchmark Factory® for Databases is a database replay and performance testing tool that stress tests your environment by simulating users and SQL transactions on the database. Developers and QA professionals use Benchmark Factory and Toad to test SQL and database code against development SLAs and scalability. DBAs use Benchmark Factory and Toad to replay database workload or utilize industry standard benchmarks to mitigate the risks of database upgrades, migrations or patch releases.</span><br></pre></td></tr></table></figure></p><ul><li>坑(最前面是解决方案 链接的名称就是坑的描述)<ul><li><code>忽略</code><a href="http://blog.sina.com.cn/s/blog_5674f6d401012ekw.html" target="_blank" rel="noopener">Oracle安装错误ora-00922（缺少或无效选项）</a></li><li><code>GK 如何安装 Oracle</code><a href="https://www.cnblogs.com/liuhongfeng/p/5267549.html" target="_blank" rel="noopener">Windows下Oracle安装图解—-oracle-win-64-11g 详细安装步骤</a></li><li><code>未安装客户端</code> <a href="https://blog.csdn.net/huoyunshen88/article/details/26725045" target="_blank" rel="noopener">TOAD OR PLSQL 连接 ORACLE ，Toad报“No valid Oracle Client found”</a></li><li><code>无效 Origin-Others</code><a href="https://blog.csdn.net/qq_35396447/article/details/78072218" target="_blank" rel="noopener">oracle配置监听问题——注册表中没有OracleOraDb11g_home1TNSListener</a></li><li><code>删除注册表项后重启</code> <a href="https://blog.csdn.net/weixin_37817685/article/details/60877927" target="_blank" rel="noopener">找不到OracleMTSRecoveryService</a></li><li><code>忽略</code>[orapwd.exe Unable to find error file”%ORACLE_HOME%”\RDBMS\opw]</li><li><code>忽略</code>INS-20802 Oracle Net Configuration Assistant 失败。<a href="https://blog.csdn.net/typa01_kk/article/details/40452647" target="_blank" rel="noopener">信息: Oracle Database Configuration Assistant 失败</a></li></ul></li></ul><p><code>GK: EF模型 和 ORM 的区别 -CSDN</code><br><a href="https://www.cnblogs.com/yaopengfei/p/9196962.html" target="_blank" rel="noopener">ORM系列之Entity FrameWork详解</a></p><p><img src="/assets/2019-07-02-ABP-Learning/没问题可删.png" alt="没问题可删"></p><p><img src="/assets/2019-07-02-ABP-Learning/客户端.png" alt="客户端"></p><p><img src="/assets/2019-07-02-ABP-Learning/IMG_20190624_160350.jpg" alt="toad-1-安装时只用选toad-for-oracle"></p><p><img src="/assets/2019-07-02-ABP-Learning/IMG_20190624_165014.jpg" alt="toad-2-环境配置"></p><p><img src="/assets/2019-07-02-ABP-Learning/IMG_20190624_171722.jpg" alt="toad-3-貌似正常的环境"></p><h1 id="C-编程入门"><a href="#C-编程入门" class="headerlink" title="C#编程入门"></a>C#编程入门</h1><p><code>有编程基础的话</code>这一部分 基本可以边上手边学的</p><p><code>SK: Essential C# C# &quot;本质论&quot; filetype:pdf -博客 -baidu</code><br>    <a href="https://book.douban.com/subject/5243513/" target="_blank" rel="noopener">C#本质论</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types" target="_blank" rel="noopener">整型数值类型（C# 参考）</a><br><a href="https://www.cnblogs.com/EthanCai/archive/2008/07/06/1237012.html" target="_blank" rel="noopener">避免对C#中float，double，decimal的错误理解</a></p><p><code>SK: Google 搜索 问号</code><br><a href="http://www.kbase101.com/question/51213.html" target="_blank" rel="noopener">如何谷歌一个问号</a><br><a href="https://zhuanlan.zhihu.com/p/22161675" target="_blank" rel="noopener">Google Hacking————你真的会用Google吗？</a></p><blockquote><p>“+”强制搜索其后的一个单词，可以取消之前说的Google对常用单词的忽视(AND逻辑)，<br>但是大部分常用英文符号(如问号，句号，逗号等)无法成为搜索关键字，加强制也不行；</p></blockquote><p>SO <code>SK: &quot;decimal?&quot;</code>是不行的, 要使用<code>SK: decimal 问号</code><br><a href="https://www.cnblogs.com/darrenji/p/3824857.html" target="_blank" rel="noopener">C#中,为什么在值类型后面加问号</a><br>decimal?是可空类型就是可以将值设置为Null，decimal 不能设置为null<br>另见<a href="https://linq2db.github.io/api/LinqToDB.LinqExtensions.html" target="_blank" rel="noopener">Class LinqExtensions: InsertWithDecimalIdentity</a></p><h1 id="DotNet入门"><a href="#DotNet入门" class="headerlink" title="DotNet入门"></a>DotNet入门</h1><p><strong>背书</strong></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/ASP.NET" target="_blank" rel="noopener">ASP.Net -Wiki</a>是由微软在.NET Framework框架中所提供，开发Web应用程序的<strong>类库</strong>，<br>封装在System.Web.dll文件中，显露出System.Web名字空间，并提供ASP.NET网页处理、扩展以及HTTP通道的应用程序与通信处理等工作，以及Web Service的基础架构。<br>ASP.NET是ASP技术的后继者，但它的发展性要比ASP技术要强大许多。</p></blockquote><blockquote><p>为了因应云端化所诱发的多作业平台集成与开发能力，微软特别开发一个新一代的 ASP.NET，称为 ASP.NET vNext，<br>并于 2014 年命名为 ASP.NET 5，但随后于 2016 年将它更名为 <strong>ASP.NET Core</strong>，<br>由于架构上的差异颇大，因此未来 ASP.NET 与 ASP.NET Core 将是分别发展与维护，<br>Windows 平台的 ASP.NET 4.6 以上版本仍维持 Windows Only，但 ASP.NET Core 则是具有跨平台 (Windows, Mac OSX 与 Linux) 的能力。</p></blockquote><h2 id="遇见的很多问题及其大致解决思路"><a href="#遇见的很多问题及其大致解决思路" class="headerlink" title="遇见的很多问题及其大致解决思路"></a>遇见的很多问题及其大致解决思路</h2><p><code>大都不是什么大不了的问题</code></p><p><a href="https://docs.microsoft.com/zh-CN/dotnet/csharp/language-reference/keywords/virtual" target="_blank" rel="noopener">virtual（C# 参考）</a></p><p><code>SK: Visual Studio 2017 C# 代码高亮 using &quot;错误&quot; -CSDN -程序错误 -插件 -更新 -调试</code><br>    <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/null-coalescing-operator" target="_blank" rel="noopener">?? 运算符（C# 参考）</a></p><p><code>SK: VS2017 ASP.NET NUGET 程序集引用 報紅 但是程序可以正常運行</code><br>    <a href="https://blog.csdn.net/u012751272/article/details/79400008" target="_blank" rel="noopener">解决.NET 项目引用类库出现黄色警告</a><br>    <a href="https://blog.csdn.net/weixin_33738555/article/details/85962141" target="_blank" rel="noopener">【Visual Studio】项目的引用显示黄色叹号</a></p><p><code>SK: 如何 更改所引用的工程文件的.Net版本 感叹号</code><br>    <a href="http://www.voidcn.com/article/p-rmbmlvkk-rh.html" target="_blank" rel="noopener">C# 工程中引用出现感叹号</a><br>    <a href="https://blog.csdn.net/CrackLibby/article/details/47665745" target="_blank" rel="noopener">C# 工程中引用出现感叹号</a><br>    <a href="https://blog.csdn.net/jl1134069094/article/details/51151429" target="_blank" rel="noopener">VS中修改.net版本</a></p><p><code>SK: Microsoft.AI.Web 黄色叹号</code><br>    <a href="http://landcareweb.com/questions/25321/wu-fa-jia-zai-wen-jian-huo-cheng-xu-ji-microsoft-ai-web-huo-qi-yi-lai-xiang-zhi-yi-gai-xi-tong-zhao-bu-dao-zhi-ding-de-wen-jian" target="_blank" rel="noopener">无法加载文件或程序集“Microsoft.AI.Web”或其依赖项之一。该系统找不到指定的文件</a></p><p><code>SK: 未能找到类型或命名空间名 &quot;AutoMap From&quot;</code><br>    <a href="https://www.cnblogs.com/xdot/p/10432966.html" target="_blank" rel="noopener">VS的ASP.NET项目中cshtml关键词出错 红线，当前上下文中不存在名称</a><br>    <a href="https://codeday.me/bug/20170611/24030.html" target="_blank" rel="noopener">c# – 命名空间不被识别(即使它在那里)</a><br>    <a href="https://blog.csdn.net/Mingyueyixi/article/details/54415902" target="_blank" rel="noopener">解决Visual studio编写C#时“未能找到类型名称或命名空间名称XXX…”错误</a></p><p><code>SK: System.BadImageFormatException: 未能加载文件或程序集 或它的某一个依赖项。试图加载格式不正确的程序。。</code><br>    ‘InstallUtil’ 不是内部或外部命令，也不是可运行的程序<br>    “vcvars32.bat”<br>    <a href="https://docs.microsoft.com/zh-CN/dotnet/framework/tools/installutil-exe-installer-tool" target="_blank" rel="noopener">Installutil.exe（安装程序工具）</a><br>    <a href="https://www.cnblogs.com/autumn/p/3575008.html" target="_blank" rel="noopener">未能加载文件或程序集“XXXXXX”或它的某一个依赖项。试图加载格式不正确的程序。</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vsCommandPrompt32(应该使用项目目录下边自带的<span class="number">233</span>)</span><br><span class="line">: 然后出现类似的内容</span><br><span class="line">&gt;"C:\Program Files (x86)\Microsoft Visual Studio\<span class="number">2017</span>\Professional\VC\Auxiliary\Build\vcvars32.bat"</span><br><span class="line">**********************************************************************</span><br><span class="line">** Visual Studio <span class="number">2017</span> Developer Command Prompt v15.<span class="number">8</span>.<span class="number">0</span></span><br><span class="line">** Copyright (c) <span class="number">2017</span> Microsoft Corporation</span><br><span class="line">**********************************************************************</span><br><span class="line">[vcvarsall.bat] Environment initialized <span class="keyword">for</span>: 'x86'</span><br><span class="line"></span><br><span class="line">: 之后就可以使用词命令安装服务了</span><br><span class="line">InstallUtil ./WinService.exe</span><br></pre></td></tr></table></figure><p><code>SK: X ORA-28547：connection to server failed，probable Oracle Net admin error</code><br><a href="https://blog.csdn.net/gaoying_blogs/article/details/45440797" target="_blank" rel="noopener">用Navicat连接Oracle数据库时报错ORA-28547:connection to server failed, probable Oracle Net admin error - 不忘初心 - CSDN博客</a></p><p><code>SK: Navicat 连接 ORACLE</code><br><a href="https://blog.csdn.net/zjx86320/article/details/49464251" target="_blank" rel="noopener">Navicat Premium 连接Oracle 数据库（图文教程） - 周江霄 - CSDN博客</a></p><p><code>SK: 如何 测试 IIS Express Web API postman</code><br>    <a href="https://www.toutiao.com/i6489186032729195021/" target="_blank" rel="noopener">如何在ASP.NET Core Web API测试中使用Postman</a><br>    <a href="https://blog.walterlv.com/post/use-postman-to-debug-asp-net-core-api.html" target="_blank" rel="noopener">使用 Postman 调试 ASP.NET Core 开发的 API - walterlv</a><br>    <a href="https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/first-web-api?view=aspnetcore-2.2&amp;tabs=visual-studio" target="_blank" rel="noopener">教程：使用 ASP.NET Core MVC 创建 Web API</a></p><p><code>SK: 当前不会命中断点 还未</code><br>    <a href="https://blog.csdn.net/shakspers/article/details/78978017" target="_blank" rel="noopener">VS2017调试代码显示“当前无法命中断点，还没有为该文档加载任何符号”</a><br>    <a href="https://www.cnblogs.com/MigCoder/p/3368319.html" target="_blank" rel="noopener">Visual Studio 当前不会命中断点的问题</a><br>PS: <code>只改过部分配置 实在乱掉可以参考admin的VS配置 或还原</code></p><p><a href="https://www.cnblogs.com/190196539/archive/2011/12/03/2272861.html" target="_blank" rel="noopener">SK 在证书存储区中找不到清单签名证书 </a></p><p><code>执行interfaceRpo.Get遇到异常(莫非是由于没有实现..?)</code><a href="https://www.cnblogs.com/senyier/p/7298759.html" target="_blank" rel="noopener">“System.Reflection.AmbiguousMatchException”类型的异常在 mscorlib.dll 中发生</a></p><h2 id="ABP框架"><a href="#ABP框架" class="headerlink" title="ABP框架"></a>ABP框架</h2><p><a href="https://www.processon.com/diagraming/5d19728ce4b014412aa8ddab" target="_blank" rel="noopener">ABP简单架构</a></p><p><code>强调</code>对数据进行变动的是业务(Business), 仓储只实现查询, 数据变动已经被基础的仓储接口实现</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>SK: &quot;IRepository&quot; docs 教程</code><br><a href="https://www.cnblogs.com/yabu007/p/8134792.html" target="_blank" rel="noopener">ABP 教程文档 1-1 手把手引进门之 AngularJs, ASP.NET MVC, Web API 和 EntityFramework（官方教程翻译版 版本3.2.5）含学习资料</a><br><a href="https://docs.microsoft.com/zh-CN/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design" target="_blank" rel="noopener">设计基础结构持久性层</a></p><p><code>SK: IRepository Query接口 用法</code><br><a href="https://www.lanhusoft.com/Article/637.html" target="_blank" rel="noopener">NopCommerce源码架构详解–EF数据访问实例详解</a><br><a href="https://www.cnblogs.com/gaochundong/archive/2013/06/06/entityframework_usage_repository_unitofwork.html" target="_blank" rel="noopener">EntityFramework用法探索（四）Repository和UnitOfWork - 匠心十年 - 博客园</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int cnt = db.GetTable&lt;ORM_ENTITY_NAME&gt;().Where(p =&gt; p.id == id).Delete();</span><br><span class="line">return cnt &gt; 0;</span><br></pre></td></tr></table></figure><p><code>SK: IRepository Get Single 区别</code><br><a href="https://www.cnblogs.com/JustRun1983/p/3307774.html" target="_blank" rel="noopener">分享基于Entity Framework的Repository模式设计（附源码）</a></p><p><code>SK: &quot;System.Reflection.AmbiguousMatchException&quot; (位于 mscorlib.dll 中</code><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.ambiguousmatchexception.-ctor?redirectedfrom=MSDN&amp;view=netframework-4.8#System_Reflection_AmbiguousMatchException__ctor_System_String_System_Exception_" target="_blank" rel="noopener">微软DotNet文档  AmbiguousMatchException Constructors </a></p><hr><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><code>吐槽</code>安装 xunit生成插件后即可自动创建模板(当然, 得改改)<br><code>吐槽</code>另外 无法直接对Controller进行测试(估计需要开启服务, 且要引入HTTP以及测试的内容所处的项目 实际上项目跑起来后并不能执行测试)<br><code>吐槽</code>测试Servise又需要登录…</p><p><a href="https://www.jianshu.com/p/77f4f9175028" target="_blank" rel="noopener">这应该是postman最详细的中文使用教程了</a><br><code>SK: Postman 测试 文件接口</code><a href="https://www.cnblogs.com/shimh/p/6094410.html" target="_blank" rel="noopener">postman测试上传文件</a></p><p><code>SK: xunit Microsoft.VisualStudio.TestTools.UnitTesting 区别</code><a href="https://www.cnblogs.com/zhaopei/p/UnitTesting.html" target="_blank" rel="noopener">C#单元测试，带你快速入门</a><br><a href="https://docs.microsoft.com/zh-cn/visualstudio/test/install-third-party-unit-test-frameworks?view=vs-2019" target="_blank" rel="noopener">安装单元测试框架</a><br><a href="https://docs.microsoft.com/zh-cn/visualstudio/test/live-unit-testing-intro?view=vs-2019" target="_blank" rel="noopener">Live Unit Testing 简介</a><br><code>SK VS 右键创建 Xunit 单元测试</code><br>    <a href="https://www.cnblogs.com/cgzl/p/8283610.html" target="_blank" rel="noopener">使用xUnit为.net core程序进行单元测试(1)</a><br>    <a href="https://jingyan.baidu.com/article/6b97984dd9adb31ca2b0bfe0.html" target="_blank" rel="noopener">Visual Studio 2017 优雅单元测试</a></p><p><a href="http://www.ituring.com.cn/article/8242" target="_blank" rel="noopener">代码质量随想录（六）用心写好注释</a><br><a href="https://codecafe1984.wordpress.com/2012/08/04/thinking_in_code_quality_6_write_elegant_comments_zh_cn/" target="_blank" rel="noopener">代码质量随想录（六）用心写好注释</a></p><p>在持久仓库调用</p><ol><li><a href="https://docs.microsoft.com/zh-CN/dotnet/api/system.data.linq.datacontext.gettable?view=netframework-4.8" target="_blank" rel="noopener">DataContext.GetTable<entitytype> Method</entitytype></a></li><li>Query<entitytype></entitytype></li><li>Excute<entitytype></entitytype></li></ol><p>当<entitytype>与仓库实际的EntityType不符时(即直接执行任何非声明仓库的sql语句)<strong>Xunit单元测试</strong>都会出现以下类似的错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.Reflection.TargetInvocationException</span><br><span class="line">System.UnauthorizedAccessException</span><br></pre></td></tr></table></figure></entitytype></p><p>使用以下语句后可以保证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// IUnitOfWorkManager中IUnitOfWorkCompleteHandle Begin();</span><br><span class="line">using (var uow = _unitOfWork.Begin())</span><br><span class="line">&#123;</span><br><span class="line">    var result = _testerService.TestFun(entity);</span><br><span class="line">    Assert.True(result != null, &quot;测试成功!&quot;);</span><br><span class="line">    // IUnitOfWorkCompleteHandle中void Complete();</span><br><span class="line">    uow.Complete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SK: ABP 联查 IRepository</code></p><ul><li><code>无果</code><a href="https://www.cnblogs.com/alunchen/p/6835297.html" target="_blank" rel="noopener">ABP 数据库 – ABP&amp;EF中的多表、关联查询</a>这个类似JPA的语法</li></ul><p><code>SK: IUnitOfWorkCompleteHandle Begin()</code><a href="https://www.bbsmax.com/A/kmzLPjobzG/" target="_blank" rel="noopener">ABP拦截器之UnitOfWorkRegistrar(二)</a></p><blockquote><p>如果一个带工作单元的方法调用了另外一个带工作单元的方法的时候，那么这两个方法是会共享相同的连接和事物的，并且第一个调用的方法管理这个工作单元，第二个进行复用，所以上面的这个ICurrentUnitOfWorkProvider接口主要是为了解决多个工作单元互相调用的问题。<br><a href="https://blog.csdn.net/guo13313/article/details/50608080" target="_blank" rel="noopener">VS中如何添加自定义 代码片段 </a></p></blockquote><p>单元测试报告显示<br><code>System.InvalidOperationException : 序列不包含任何元素</code><br>    这个貌似是由于没有查询到元素(但加上后面的关联单元语句后会返回null)<br><code>Message: System.NullReferenceException : 未将对象引用设置到对象的实例。</code><br>    使用了Single方法<code>Gets exactly one entity with given predicate. Throws exception if no entity or more than one entity.</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class NameRepository : RepositoryBase&lt;Name_Table&gt;, INameRepository&#123;</span><br><span class="line">    // implement</span><br><span class="line">&#125;</span><br><span class="line">// Name必须相同, 否则会</span><br><span class="line">Message: Castle.MicroKernel.Handlers.HandlerException : Can&apos;t create component &apos;Sample.Abp.Service.NameService&apos; as it has dependencies to be satisfied.</span><br><span class="line"></span><br><span class="line">&apos;Sample.Abp.Service.NameService&apos; is waiting for the following dependencies:</span><br><span class="line">- Service &apos;Sample.Abp.IRepositories.NameRepository&apos; which was not registered.</span><br></pre></td></tr></table></figure><p><code>SK: C# 类似 org.springframework.beans BeanUtils.copyProperties 的方法</code><a href="https://blog.csdn.net/q649381130/article/details/78064650" target="_blank" rel="noopener">慎用BeanUtils的对象拷贝方法</a></p><h4 id="初始化测试资源"><a href="#初始化测试资源" class="headerlink" title="初始化测试资源"></a>初始化测试资源</h4><p><a href="https://www.cnblogs.com/liuning8023/archive/2012/07/22/2603819.html" target="_blank" rel="noopener">C# 析构函数（Destructor）和终结器（Finalizer）——托管资源的释放</a><br>-&gt;<code>官方</code><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/destructors" target="_blank" rel="noopener">终结器（C# 编程指南）</a><br><strong>我们只能知道GC会回收这两个对象，但在.NET中，由于GC的存在，究竟何时调用析构函数我们是不能确认的。 </strong></p><p><a href="https://blog.csdn.net/cpcpc/article/details/6185946" target="_blank" rel="noopener">.NET 单元测试样例 (NUnit工具)</a></p><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><p><code>Xunit.Abstractions.IAfterTestFinished;</code><br><code>SK: XUnit After Test Finished</code><a href="https://stackoverflow.com/questions/13829737/run-code-once-before-and-after-all-tests-in-xunit-net" target="_blank" rel="noopener">Run code once before and after ALL tests in xUnit.net</a><br><code>SK: C# lambda 表达式</code><a href="https://docs.microsoft.com/zh-CN/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions" target="_blank" rel="noopener">Lambda 表达式（C# 编程指南）</a></p><p>最后发现 官方的文档中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// 摘要:</span><br><span class="line">//     提供一种用于释放非托管资源的机制。 若要浏览此类型的.NET Framework 源代码，请参阅Reference Source。</span><br><span class="line">[ComVisible(true)]</span><br><span class="line">public interface IDisposable</span><br><span class="line">&#123;</span><br><span class="line">        //</span><br><span class="line">        // 摘要:</span><br><span class="line">        //     执行与释放或重置非托管资源关联的应用程序定义的任务。</span><br><span class="line">        void Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>于是只需要重载Dispose方法就ok<br><code>xunit错误也会执行 其他没试过</code></p><p>最后:<br><a href="https://codeday.me/bug/20180822/226609.html" target="_blank" rel="noopener">c# – 使用XUnit断言异常</a></p><hr><h3 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h3><p><code>SK: 未找到WAS 服务</code><a href="https://jingyan.baidu.com/article/15622f2410f770fdfcbea5d3.html" target="_blank" rel="noopener">在计算机“.”上没有找到WAS服务</a><br><a href="https://www.cnblogs.com/ggll611928/p/6525202.html" target="_blank" rel="noopener">HTTP 错误 404.0 - Not Found</a></p><p><code>快捷键在调试选项下可查看</code></p><p><a href="https://q.cnblogs.com/q/90874/" target="_blank" rel="noopener">.net core 附加到进程调试<em>已解决</em>博问_博客园</a></p><blockquote><p>依然是可以的，只是进程不在是原来的w3wp进程了，而是dotnet.exe。</p><p>不过最好建议使用IIS进行反向代理，这样就可以通过进程的<code>User Name</code>明显的看到是在哪个dotnet.exe进程中了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      上手ASP.NET Boilerplate (ASP.NET样板项目) ABP-Learning
    
    </summary>
    
      <category term="DotNet" scheme="https://sailhe.github.io/categories/DotNet/"/>
    
    
      <category term="流水帐" scheme="https://sailhe.github.io/tags/%E6%B5%81%E6%B0%B4%E5%B8%90/"/>
    
  </entry>
  
  <entry>
    <title>实用性最强的设计模式</title>
    <link href="https://sailhe.github.io/2019/06/17/%E5%AE%9E%E7%94%A8%E6%80%A7%E6%9C%80%E5%BC%BA%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://sailhe.github.io/2019/06/17/实用性最强的设计模式/</id>
    <published>2019-06-17T07:45:27.000Z</published>
    <updated>2024-02-19T09:17:06.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例虽然饱受诟病, 但用处特别广泛, 各种<code>instance</code>以及<code>singleton</code>,<code>Global</code>等字眼儿基本上都是单例的特征.</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><a href="https://zh.wikipedia.org/wiki/观察者模式" target="_blank" rel="noopener">观察者模式</a></h2><p>是软件设计模式的一种。在此种模式中，一个<strong>目标对象</strong>管理所有相依于它的<strong>观察者对象</strong>，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统.</p><p>观察者模式: 观察者(Observer)-目标主题(Subject)<br>别称: </p><ul><li>发布-订阅(Publish/Subscribe)模式</li><li>源-监听(Source/Listener)模式</li></ul><p>实现时常用词汇:</p><ul><li>抽象-基础-具体</li><li>目标(主题发布者/源)</li><li>观察者(主题订阅者/监听者)</li></ul><p>表面上, 它定义了一种一对多的依赖关系: 一个主题，多个观察者，当主题发生变化的时候，会主动的通知观察者，这样观察者便能针对主题发生的变化，执行某些对应的动作.<br>实际上, 一个观察者可以同时订阅多个主题, 因此是一种多对多的依赖关系.</p><h3 id="通用类图"><a href="#通用类图" class="headerlink" title="通用类图"></a>通用类图</h3><p><img src="/assets/img/sharding/design-pattern/Observer-pattern-class-diagram.png" alt="Servlet事件机制-事件"><br>详细类图, 这张感觉命名好一点<br><img src="/assets/img/sharding/design-pattern/Observer-pattern-class-diagram-info.png" alt="Servlet事件机制-事件"></p><h4 id="易混淆概念"><a href="#易混淆概念" class="headerlink" title="易混淆概念"></a>易混淆概念</h4><p>Subject:</p><ul><li>添附(Attach)：新增观察者到串炼内，以追踪目标对象的变化。&lt;==&gt; Add</li><li>解附(Detach)：将已经存在的观察者从串炼中移除。         &lt;==&gt; Delete</li><li>通知(NotifyObserver)：利用观察者所提供的更新函式来通知此目标已经产生变化。</li></ul><p>Observer</p><ul><li>Notify &lt;==&gt; Update // 一个概念, 都是表示更新观察者状态</li></ul><h3 id="Tomcat的观察者模式"><a href="#Tomcat的观察者模式" class="headerlink" title="Tomcat的观察者模式"></a>Tomcat的观察者模式</h3><p>此处讲述Tomcat中用到观察者模式的两个地方: Servlet事件机制 以及 生命周期管理机制, 当然整个 Tomcat 服务器中这种模式使用肯定远不止于此限于篇幅(事实上貌似容器本身也是一种发布者), 不予论述.</p><h4 id="Servlet事件机制"><a href="#Servlet事件机制" class="headerlink" title="Servlet事件机制"></a>Servlet事件机制</h4><p>Tomcat Servlet 中提供了很多种<strong>事件观察者接口</strong>，此处仅列举5个：<br>HttpSessionAttributeListener, ServletRequestAttributeListener, ServletContextAttributeListener, ServletRequestListener, ServletContextListener<br>如下图所示：</p><ul><li>事件源<br><img src="/assets/img/sharding/tomcat/EventPublisher.png" alt="Servlet事件机制-事件"></li><li>监听者<br><img src="/assets/img/sharding/tomcat/EventListeners.png" alt="Servlet事件机制-事件监听器"></li></ul><p>需要注意的是它们都继承于 EventListeners 接口, 这是java.util中的接口, 始于JDK1.1, 其是一个空接口, 什么也没写<br>这样实现不怎么现代化, 接下来看看Tomcat的生命周期中的观察者模式实现</p><h4 id="生命周期管理机制"><a href="#生命周期管理机制" class="headerlink" title="生命周期管理机制"></a>生命周期管理机制</h4><blockquote><p><a href="https://www.jianshu.com/p/4e4eac05815f" target="_blank" rel="noopener">Servlet容器的启动过程</a><br> <img src="/assets/img/sharding/tomcat/Tomcat的容器体系.png" alt="Tomcat的容器体系"><br> 总之, 真正管理Servlet的容器是Context，一个Context对应一个Web工程，也就是webapps下的一个项目，Context中的Wrapper也就是包装后的servlet。<br> 一个web应用对应一个Context容器，当添加一个web应用的时候会创建一个StandardContext容器，并且做相关配置，其中最重要的是ContextConfig（实际上是一个监听器），这个类将负责整个web应用的解析工作，当 context容器的状态被更改时，ContextConfig会被通知，做相关解析工作，最后将这个容器加到父容器Host中。</p></blockquote><p>以上是此模式的大概应用, 此处是类图</p><ul><li>生命周期(源)<br><img src="/assets/img/sharding/tomcat/Lifecycle.png" alt="Lifecycle"></li><li>生命周期监听器<br><img src="/assets/img/sharding/tomcat/LifecycleListener.png" alt="LifecycleListener"></li><li>其它相关类, 用于传递事件状态, 等等, 仅列出主要的几个中的部分<br><img src="/assets/img/sharding/tomcat/Lifecycle其它相关类.png" alt="Lifecycle其它相关类"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 实际源码远不及此 此处仅提取观察者模式中的关键部分, 作为 模式实现 和 理想模式 之间的对比</span></span><br><span class="line"><span class="comment">// Lifecycle: 生命周期是源目标</span></span><br><span class="line"><span class="comment">// LifecycleBase 是基础生命周期, 继承了基础源的类称具体源</span></span><br><span class="line"><span class="comment">// 监听者(LifecycleListener)与此类似, 故不赘述</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBase</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是发布者中的监听器们 此处使用List接口实现(PS: CopyOnWriteArrayList是ArrayList的线程安全变体)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LifecycleListener&gt; lifecycleListeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前生命周期源的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> LifecycleState state = LifecycleState.NEW;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 添加一个监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">        lifecycleListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 移除一个监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">        lifecycleListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发(通知)所有监听器, 与通用类图中的uptate/notifyObserves是一个意义</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将源作为引用随事件传入监听器</span></span><br><span class="line">        LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(<span class="keyword">this</span>, type, data);</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">            listener.lifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Wiki: <a href="https://zh.wikipedia.org/wiki/设计模式_(计算机)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/设计模式_(计算机)</a></p><p><a href="https://www.cnblogs.com/luohanguo/p/7825656.html" target="_blank" rel="noopener">观察者模式</a><br><code>这是一个系列</code><a href="https://www.jianshu.com/p/0092ee6e57ca" target="_blank" rel="noopener">Tomcat生命周期管理与观察者模式</a><br><a href="https://www.jianshu.com/p/f987141887bb" target="_blank" rel="noopener">Tomcat 源码分析 项目启动 (基于8.0.5)</a><br><a href="https://my.oschina.net/u/227422/blog/66213" target="_blank" rel="noopener"> 从tomcat中学习观察者模式 </a></p><ul><li>更新 <code>2024-02-19 17:15</code></li></ul>]]></content>
    
    <summary type="html">
    
      介绍一点设计模式的知识
    
    </summary>
    
      <category term="Induction" scheme="https://sailhe.github.io/categories/Induction/"/>
    
    
      <category term="DesignPatterns" scheme="https://sailhe.github.io/tags/DesignPatterns/"/>
    
      <category term="TomCat" scheme="https://sailhe.github.io/tags/TomCat/"/>
    
  </entry>
  
  <entry>
    <title>古老的Servlet技术</title>
    <link href="https://sailhe.github.io/2019/06/16/%E5%8F%A4%E8%80%81%E7%9A%84Servlet%E6%8A%80%E6%9C%AF/"/>
    <id>https://sailhe.github.io/2019/06/16/古老的Servlet技术/</id>
    <published>2019-06-16T03:56:22.000Z</published>
    <updated>2024-02-19T09:14:06.753Z</updated>
    
    <content type="html"><![CDATA[<p>已经是上世纪90年代的技术了, 但想要学习Spring全家桶还得学.</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><a href="https://zh.wikipedia.org/wiki/JavaBeans" target="_blank" rel="noopener">JavaBeans</a>是Java中一种特殊的类，可以将多个对象封装到一个对象（bean）中。特点是<strong>可序列化</strong>, <strong>提供无参构造器</strong>, <strong>提供getter方法和setter方法</strong>访问对象的属性。名称中的“Bean”是用于Java的<strong>可重用软件组件</strong>的惯用叫法。 </p><p><a href="https://www.jianshu.com/p/f643f1fa1a20" target="_blank" rel="noopener">浅谈model, orm, dao和active record的区别</a></p><p><a href="https://zh.wikipedia.org/wiki/Struts2" target="_blank" rel="noopener">Apache Struts 2</a>是一个用于开发Java EE网络应用程序的开放源代码网页应用程序架构。它利用并延伸了Java Servlet API，鼓励开发者采用MVC架构。 </p><h1 id="Java-Servlet"><a href="#Java-Servlet" class="headerlink" title="Java Servlet"></a><a href="https://zh.wikipedia.org/wiki/Java_Servlet" target="_blank" rel="noopener">Java Servlet</a></h1><blockquote><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。<br> 其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，<strong>广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</strong><br> Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但<strong>绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</strong><br> 最早支持Servlet标准的是JavaSoft的Java Web Server。此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。<br> <img src="/assets/img/sharding/JSPLife.png" alt="Life of a JSP file"><br> <img src="/assets/img/sharding/ModelViewControllerDiagramZh.png" alt="ModelViewControllerDiagramZh"></p></blockquote><blockquote><p><strong>工作模式</strong><br>  客户端<strong>发送请求</strong>至服务器<br>  服务器<strong>启动</strong>并<strong>调用</strong>Servlet，Servlet根据客户端请求<strong>生成响应内容</strong>并将其传给服务器<br>  服务器将<strong>响应返回</strong>客户端<br>  其他<br>以上引用自标题指向的wiki, 无内容改动, 简而言之, Servlet是用来响应客户端请求然后生成Html的服务端java小程序, 这是Javaweb的根本<br>HttpServlet拓展了Servlet<br>Java服务器页面(<a href="https://zh.wikipedia.org/wiki/JSP" target="_blank" rel="noopener">JSP</a>)又拓展了HttpServlet<br>  其功能是使用HTML的书写格式，在适当的地方加入Java代码片段,<br>  即: Servlet是在服务器端java程序中写Html<br>      JSP是在JSP页面中<code>感觉不能说是前端</code>书写java代码, 类似于JavaScript脚本, 只是后者不能直接调用与服务器相关的内容, 比如文件<code>不是指客户端的文件</code>或数据库</p></blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html#N10085" target="_blank" rel="noopener">Servlet 工作原理解析</a></p><ul><li>Servlet - 接口 - 容器{ Jetty; Tomcat }</li><li>里面有类图; 时序图; 讲解详细, 此处就不再赘述</li></ul><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a><a href="https://zh.wikipedia.org/zh-cn/Apache_Tomcat" target="_blank" rel="noopener">Tomcat</a></h1><ol><li>SpringBoot 内置 tomcat 依赖</li><li>使用maven打成war包后使用外置tomcat启动</li><li>Tomcat提供了一个Jasper编译器用以将JSP编译成对应的Servlet。 </li></ol><p><code>SK</code>tomcat 启动  war包</p><p><code>SK: 如何 下载 Tomcat 源码</code><a href="https://www.jianshu.com/p/eb9f628cf82b" target="_blank" rel="noopener">死磕tomcat源码(一)之源码下载与导入IDEA</a><br>-&gt; <a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">SRC-8.X</a></p><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><p>‘SK: Spring MVC 和 三层架构’<a href="https://juejin.im/post/5929259b44d90400642194f3" target="_blank" rel="noopener">MVC 与三层架构</a></p><ol><li><code>太笼统</code><a href="https://www.jianshu.com/p/a5195a08da3e" target="_blank" rel="noopener">Spring Boot - Tomcat容器部署</a></li><li><a href="https://www.cnblogs.com/laogai/p/4935193.html" target="_blank" rel="noopener">tomcat本地部署war包的方式</a></li><li><a href="https://www.jianshu.com/p/e48ae3b99573" target="_blank" rel="noopener">Tomcat部署java web项目,war包方式</a></li><li><code>SK: SpringMVC 和 Servlet</code><a href="https://juejin.im/post/5a9f3ddb5188255585071151" target="_blank" rel="noopener">Servlet 到 Spring MVC 的简化之路</a></li><li><a href="https://www.jianshu.com/p/3bd8b40400c9" target="_blank" rel="noopener">Spring Framework 整体架构</a></li><li><code>SK: Spring MVC</code><a href="https://www.jianshu.com/p/91a2d0a1e45a" target="_blank" rel="noopener">Spring MVC【入门】就这一篇！</a></li><li><a href="https://www.oschina.net/news/77354/http-get-post-different" target="_blank" rel="noopener">99%的人理解错 HTTP 中 GET 与 POST 的区别</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener">MDN-GET</a></li><li><a href="https://blog.csdn.net/qq_24452475/article/details/51068258" target="_blank" rel="noopener">Spring、Struts、Hibernate框架之间的关系是什么以及怎么处理</a></li><li><a href="https://www.jianshu.com/p/f1e5f789939c" target="_blank" rel="noopener">关于SpringMVC和Struts2的区别</a></li><li><a href="https://www.jianshu.com/p/3e7e40bde455" target="_blank" rel="noopener">Struts1和Struts2的区别和对比</a></li><li><code>注意 MVC不是分层</code><a href="https://www.ruanyifeng.com/blog/2007/11/mvc.html" target="_blank" rel="noopener">MVC模式</a></li><li><a href="https://blog.csdn.net/zhangli_/article/details/50419783" target="_blank" rel="noopener">注意 MVC不是设计模式 而是架构模式 确切地说是一种理念</a></li><li><a href="http://er.dadaaierer.com/?p=60" target="_blank" rel="noopener">注意 MVC不是框架模式 框架&lt;=!=&gt;架构</a></li></ol><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>Links[4]中提及的:</p><blockquote><p>模型（Model）：封装了应用程序的数据，通常由POJO类组成<br>Links[6]中提及的:<br>M 代表 模型（Model） 模型是什么呢？ 模型就是数据，就是 dao,bean<br><strong>可能</strong>容易误导读者<br>另外Links[6]中的命名方式也容易使初学者混淆<strong>层</strong>的概念, 比如DAO是<strong>数据访问对象</strong>, 而不是<strong>数据访问层</strong><br>其中还使用了IDEA作为教程新建HelloWorld项目</p></blockquote><p><code>SK: MVC 模型到视图 虚线 意思</code><a href="https://blog.csdn.net/dqjyong/article/details/7697558" target="_blank" rel="noopener">MVC设计模式详解</a><br> -&gt;<br><code>SK: MVC设计模式详解 &quot;C对M&quot; &quot;C对V：Outlet&quot;</code><a href="https://www.cnblogs.com/blogoflzh/p/4684576.html" target="_blank" rel="noopener">iOS学习之MVC设计模式的理解</a><br> -&gt;<br><code>Origin link</code><a href="http://blog.sina.com.cn/s/blog_4a3dcc3901010062.html" target="_blank" rel="noopener">IOS学习之——MVC模式</a></p><p><strong>下边者篇文章对MVC讲解的比较全面且深入, 解释了wiki的那张图</strong><br><code>SK: https://upload.wikimedia.org/wikipedia/commons/thumb/f/f0/ModelViewControllerDiagramZh.png/200px-ModelViewControllerDiagramZh.png mvc</code><br><a href="https://www.jianshu.com/p/5e94569a430a" target="_blank" rel="noopener">MVC，MVP，MVVM区别</a><br><code>Origin Link</code><a href="https://www.cnblogs.com/JustRun1983/p/3727560.html" target="_blank" rel="noopener">MVC, MVP, MVVM比较以及区别(下)</a><br><a href="https://www.cnblogs.com/JustRun1983/p/3679827.html" target="_blank" rel="noopener">MVC, MVP, MVVM比较以及区别(上)</a></p><p>类似的搜索套路(但里面的内容需要商榷):<br><code>SK: 设计模式 架构模式</code><a href="https://blog.csdn.net/cxzhq2002/article/details/78160530" target="_blank" rel="noopener">架构模式(Architectural Pattern)、设计模式(Design Pattern)、代码模式(Coding Pattern)</a><br><code>SK: &quot;架构模式(Architectural Pattern)、设计模式(Design Pattern)、代码模式(Coding Pattern)&quot;</code><a href="https://www.cnblogs.com/duanxz/archive/2012/06/05/2536801.html" target="_blank" rel="noopener">架构模式(Architectural Pattern)、设计模式(Design Pattern)、代码模式(Coding Pattern)</a></p><p><a href="https://www.cnblogs.com/HondaHsu/archive/2007/07/03/732754.html" target="_blank" rel="noopener">基于UML和ASP.NET实现三层B/S结构系统开发</a>中提到Domain是<strong>系统中关键的类</strong></p><p>这里提到的三层的一个关系, 并非简单的上层依赖下层的关系, 由于依赖注入的存在, BLL可以使用DAL的接口而不是实现<br><code>不过我始终认为三层架构只能是三层 名字不能再多加层了</code><a href="http://www.dalbll.com/Group/Topic/ArchitecturedDesign/4971" target="_blank" rel="noopener">什么是三层架构？你真的理解分层的意义吗？</a></p><p>这篇表现了 BS的三层{Browser-Server-DataBase} 和 应用三层{UI-BLL-DAL} 的关系, 但其中提到的 dao层 DAO 是对象不是层, DAO 属于 DAL层<br><a href="https://www.cnblogs.com/zhangyinhua/p/7645581.html" target="_blank" rel="noopener">JavaWeb（六）之MVC与三层架构设计</a></p><p><a href="https://wxs.me/2069" target="_blank" rel="noopener">几种常见的软件架构风格介绍</a></p>]]></content>
    
    <summary type="html">
    
      记录学习Servlet相关的知识的情况
    
    </summary>
    
      <category term="Experience" scheme="https://sailhe.github.io/categories/Experience/"/>
    
    
      <category term="Servlet" scheme="https://sailhe.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>软件构架、架构和框架的区别</title>
    <link href="https://sailhe.github.io/2019/06/09/%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%9E%B6%E3%80%81%E6%9E%B6%E6%9E%84%E5%92%8C%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sailhe.github.io/2019/06/09/软件构架、架构和框架的区别/</id>
    <published>2019-06-09T12:16:00.000Z</published>
    <updated>2024-02-19T09:09:36.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件框架"><a href="#软件框架" class="headerlink" title="软件框架"></a><strong>软件框架</strong></h2><p>(Software Framework)介绍 </p><blockquote><p>面向某领域（包括业务领域，如ERP，和计算领域，如GUI）的、可复用的”<strong>半成品</strong>“软件，它实现了该领域的共性部分，并提供一系列定义良好的可变点以保证灵活性和可扩展性。<br> 可以说，软件框架是<strong>领域分析结果</strong>的<strong>软件化</strong>，是领域内<strong>最终应用系统</strong>的<strong>模板</strong>。 </p></blockquote><ul><li>随着软件规模的扩大、应用的广泛和软件复用技术的发展，以子程序或类（Class）为单位的软件复用有许多不足：<blockquote><ol><li>子程序库日趋其庞大以致于使用人员难以掌握，</li><li>大多数类粒度很小，且其自身往往不能完成有用的功能。</li></ol></blockquote></li></ul><p>这一问题迫使人们在复用中将一组类（或模块）及其交互作为一个整体来考虑，由此出现了软件框架。 </p><ul><li>软件框架至少包含以下组成部分： <blockquote><ol><li>一系列完成计算的<strong>模块</strong>，在此称为<strong>构件</strong>。 </li><li>构件之间的关系与<strong>交互机制</strong>。 </li><li>一系列<strong>可变点</strong>（也称<strong>热点</strong>，<strong>Hot-spots</strong>，或<strong>调整点</strong>）。 </li><li>可变点的<strong>行为调整机制</strong>。 </li></ol></blockquote></li></ul><p>开发人员通过软件框架的<strong>行为调整机制</strong>，将领域中具体应用所特有的软件模块绑定到该软件框架的可变点，从而得到最终应用系统，这一过程称为<strong>软件框架的例化（instantiation）</strong>。<br>通过软件框架的使用，开发人员可将主要精力放在应用所特有的模块的开发上，从而大大提高了软件生产率和质量。 </p><p>软件框架的<strong>行为调整机制</strong>是指<strong>如何针对</strong>具体的应用<strong>调整</strong>该框架的<strong>可变部分</strong>、如何在<strong>可变点</strong>加入特定应用模块所采用的方法和规则。</p><ul><li>行为调整机制可分为四种：<blockquote><ol><li>模板参数化。软件框架提供代码自动生成工具，该工具根据用户设置的参数自动生成所需的代码。 </li><li>继承和多态。通过面向对象中的子类继承和重载，在子类中加入新的功能或改变父类的行为。 </li><li>动态绑定。在运行时刻动态绑定所需的对象服务，可通过软件模式技术实现。 </li><li>构件替换。通过替换框架中可插拔的构件来加入业务特定的功能， </li></ol></blockquote></li></ul><p>不同于一般的可复用软件制品，软件框架的一个显著特点是逆向控制（Inversion of Control），在复用过程中，前者需被显式调用，控制是在应用特定的模块中，软件框架则不然，应用开发人员只要将应用特定的模块绑定到框架内，框架则根据自己的交互机制自动调用该模块，控制由框架负责。 </p><ul><li>软件框架有很多种。</li></ul><blockquote><p>按其应用的范围可分为： </p><ol><li>系统基础设施框架。用于简化系统级软件的开发，如操作系统、用户界面、语言处理等，典型例子为MacApp, Microsoft’s MFC等。 </li><li>中间件集成框架。用于组装分布式应用和构件，典型例子为Microsoft’s DCOM, JavaSoft’s RMI, OMG’s CORBA等 </li><li>企业应用框架。用于各类应用领域，如电信、制造业、金融等。 </li></ol></blockquote><blockquote><p>按其表现形态可分为： </p><ol><li>白盒框架。支持白盒复用，大型的类库或子程序库通常均提供白盒框架来协助复用。 </li><li>黑盒框架。支持黑盒复用。中间件集成框架一般为黑盒框架。</li></ol></blockquote><hr><h2 id="构架和架构"><a href="#构架和架构" class="headerlink" title="构架和架构"></a><strong>构架</strong>和<strong>架构</strong></h2><p>也就是通常所说的<strong>软件体系结构(software architecture)</strong>.</p><p>体系结构一般包括三个部分:</p><ul><li>构件,用于描述计算;</li><li>连接器,用于描述构件的连接部分;</li><li>配置,将构件和连接器组成一个有机整体.<br><code>对体系结构比较严谨比较认可的定义可参见＜软件工程技术概论＞（科学出版社）．</code><blockquote><p><strong>体系结构</strong>与<strong>框架（Framework)</strong>的区别与联系如下： </p><ol><li>呈现形式不同．体系结构的呈现形式是一个<strong>设计规约</strong>，而框架则是<strong>程序代码</strong>． </li><li>目的不同．体系结构的首要目的大多是<strong>指导一个软件系统的实施与开发</strong>；而框架的首要目的是为<strong>复用</strong>．因此，<strong>一个框架可有其体系结构</strong>，用于指导该框架的开发，反之不然． </li><li>有种特殊的体系结构, <strong>DSSA(领域特定体系结构）</strong>其首要目的也是为了复用． </li><li>有个叫<strong>体系结构风格</strong>的东西，将它用程序代码实现后就成了Corba,COM之类的东西，它们俩叫<strong>体系结构框架</strong>，也叫<strong>中间件集成框架</strong>，又有人愿意叫它<strong>对象中间件</strong></li></ol></blockquote></li></ul><hr><h2 id="什么是模式？什么是框架？"><a href="#什么是模式？什么是框架？" class="headerlink" title="什么是模式？什么是框架？"></a>什么是模式？什么是框架？</h2><p>（简述） ――UB （<a href="mailto:UB5023@MSN.COM" target="_blank" rel="noopener">UB5023@MSN.COM</a>） 2003-6-6</p><p>现在软件设计里到处都是模式，框架。有次朋友问什么是模式？我也在学习中，就我的学习经验，给出以下小结。（注意：个人观点，仅供参考，欢迎指正。）</p><ol><li><p>什么是模式？</p><blockquote><p>模式，即pattern。其实就是解决某一类问题的方法论。你把解决某类问题的方法总结归纳到理论高度，那就是模式。<br>Alexander给出的经典定义是：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。<br>模式有不同的领域，建筑领域有建筑模式，软件设计领域也有设计模式。当一个领域逐渐成熟的时候，自然会出现很多模式。</p></blockquote></li><li><p>什么是框架？</p><blockquote><p>框架，即framework。其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。</p></blockquote></li><li><p>为什么要用模式？</p><blockquote><p>因为模式是一种指导，在一个良好的指导下，有助于你完成任务，有助于你作出一个优良的设计方案，达到事半功倍的效果。而且会得到解决问题的最佳办法。</p></blockquote></li><li><p>为什么要用框架？</p><blockquote><p>因为软件系统发展到今天已经很复杂了，特别是服务器端软件，设计到的知识，内容，问题太多。<br>在某些方面使用别人成熟的框架，就相当于让别人帮你完成一些基础工作，你只需要集中精力完成系统的业务逻辑设计。<br>而且框架一般是成熟，稳健的，他可以处理系统很多细节问题，比如，事物处理，安全性，数据流控制等问题。<br>还有框架一般都经过很多人使用，所以结构很好，所以扩展性也很好，而且它是不断升级的，你可以直接享受别人升级代码带来的好处。</p></blockquote></li></ol><p>框架一般处在低层应用平台（如J2EE）和高层业务逻辑之间的<strong>中间层</strong>。</p><ol start="5"><li>软件为什么要分层？<blockquote><p>为了实现“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源…总之好处很多啦：）。</p></blockquote></li></ol><hr><p><strong>以下所述主要是JAVA，J2EE方面的模式和框架：</strong></p><ol><li>常见的设计模式有什么？<blockquote><p>首先，你要了解的是GOF的《设计模式–可复用面向对象软件的基础》一书（这个可以说是程序员必备的了），注意：GOF不是一个人，而是指四个人。<br>它的原意是Gangs Of Four,就是“四人帮”，就是指此书的四个作者：Erich Gamma,Richard Helm，Ralph Johnson,John Vlissides。<br>这本书讲了23种主要的模式，包括：抽象工厂、适配器、外观模式等。<br>还有其他的很多模式，估计有100多种。</p></blockquote></li></ol><p><strong>软件设计模式太多，就我的理解简单说一下最常见的MVC模式。</strong><br><code>本人注: MVC是架构模式或者说软件设计理念 并非简单的软件设计模式 前者显然解决的问题更加抽象 应用也更广泛</code></p><p>MVC模式是1996年由Buschmann提出的：</p><ul><li>模型（Model）：就是封装数据和所有基于对这些数据的操作。</li><li>视图（View）：就是封装的是对数据显示，即用户界面。</li><li>控制器（Control）：就是封装外界作用于模型的操作和对数据流向的控制等。</li></ul><p>另外：</p><blockquote><p>RUP（Rational Unified Process）软件统一过程，XP（Extreme Programming）极端编程，这些通常被叫做“过程方法”，是一种软件项目实施过程的方法论，它是针对软件项目的实施过程提出的方法策略。也是另一个角度的模式。</p></blockquote><ol start="2"><li>常见的JAVA框架有什么？</li></ol><table><thead><tr><th>简称</th><th>全称</th><th>主要应用方面</th><th>主要应用技术</th><th>出处</th><th>简述</th><th>费用</th></tr></thead><tbody><tr><td>WAF</td><td>WEB APPLICATION FRAMEWORK</td><td>EJB层[9]</td><td>EJB等</td><td><a href="http://java.sun.com/blueprints/code/index.html" target="_blank" rel="noopener">blueprints</a></td><td>[1]</td><td>免费</td></tr><tr><td>Struts</td><td></td><td>WEB层</td><td>JSP,TagLib,JavaBean,XML等</td><td><a href="http://jakarta.apache.org/struts/index.html" target="_blank" rel="noopener">struts</a></td><td>[2]</td><td>免费</td></tr><tr><td>Turbine</td><td></td><td>WEB层</td><td>servlet等</td><td><a href="http://jakarta.apache.org/turbine/index.html" target="_blank" rel="noopener">turbine</a></td><td>[3]</td><td>免费</td></tr><tr><td>COCOON</td><td></td><td>WEB层</td><td>XML，XSP，servlet等</td><td><a href="http://cocoon.apache.org/2.0/" target="_blank" rel="noopener">cocoon</a></td><td>[4]</td><td>免费</td></tr><tr><td>ECHO</td><td></td><td>WEB层</td><td>servlet等</td><td><a href="http://www.nextapp.com/products/echo/" target="_blank" rel="noopener">echo</a></td><td>[5]</td><td>免费</td></tr><tr><td>JATO</td><td>SUN ONE Application Framework</td><td>WEB层</td><td>JSP,TagLib,JavaBean等</td><td><a href="http://www.sun.com" target="_blank" rel="noopener">sun</a></td><td>[6]</td><td>免费</td></tr><tr><td>TCF</td><td>Thin-Client Framework</td><td>JAVA GUI</td><td>JAVA application等</td><td><a href="http://www.alphaworks.ibm.com/tech/tcf" target="_blank" rel="noopener">tcf</a></td><td>[7]</td><td>收费[8]</td></tr></tbody></table><p><strong>简述WAF+STRUTS结合的例子</strong>：<br>WEB层用STRUTS，EJB层用WAF：<br>JSP(TagLib)-&gt;ActionForm-&gt;Action-&gt;<br>Event-&gt;EJBAction-&gt;EJB-&gt;DAO-&gt;Database<br>JSP（TagLib） (forward)&lt;-Action&lt;-EventResponse&lt;-</p><ul><li>拓展</li></ul><ol><li>这是SUN在展示J2EE平台时所用的例子PetStore(宠物商店系统)里面的框架。是SUN蓝皮书例子程序中提出的应用框架。它实现了 MVC和其他良好的设计模式。SUN的网站上有技术资料，最好下载PetStore来研究，WEBLOGIC里自带此系统，源码在bea/weblogic700/samples/server/src/petstore。这是学习了解J2EE的首选框架。</li><li>这是APACHE的开源项目，目前应用很广泛。基于MVC模式，结构很好，基于JSP。Jbuilder8里已经集成了STRUTS1.02的制作。</li><li>这是APACHE的开源项目。基于SERVLET。据说速度比较快，基于service（pluggable implementation可插拔的执行组件）的方式提供各种服务。</li><li>这是APACHE的一个开源项目。基于XML，基于XSP（通俗地说，XSP是在XML静态文档中加入Java程序段后形成的动态XML文档。）。特点是可以与多种数据源交互，包括文件系统，数据库，LDAP，XML资源库，网络数据源等。</li><li>nextapp公司的一个开源项目。基于SERVLET。页面可以做的很漂亮，结合echopoint，可以作出很多图形效果（里面用了jfreechart包）。使用SWING的思想来作网页，把HTML当作JAVA的类来做。但是大量使用Session，页面分帧（Frame）很多,系统资源消耗很大。</li><li>这是SUN推出的一个商业性框架，一看名字就知道是结合SUN ONE的平台推出的。我下载了JATO2.0看了一下，感觉有些简单，使用了JSP＋TagLib+JavaBean。如他的DOC所说JATO是适合用在小的WEB应用里。</li><li>这是IBM出的一个框架。基于MVC模式，基于JAVA Application。推荐一篇介绍文章：<a href="http://www-900.ibm.com/developerWorks/cn/java/j-tcf1/index.shtml" target="_blank" rel="noopener">http://www-900.ibm.com/developerWorks/cn/java/j-tcf1/index.shtml</a></li><li>(每个企业对象license:2000美元)</li><li>(WEB层也有，但是比较弱)</li></ol><p>其实本文的目的在于“抛砖引玉”，希望各路高手请你们把各种框架的特点和出处罗列一下 ，供大家参考，选用。</p><hr><p><strong>本文转载自：<a href="https://blog.csdn.net/nizhigang2000/article/details/58371" target="_blank" rel="noopener">https://blog.csdn.net/nizhigang2000/article/details/58371</a></strong><br><strong>始见于: <a href="https://my.oschina.net/duansheli/blog/292288" target="_blank" rel="noopener">https://my.oschina.net/duansheli/blog/292288</a></strong></p><ul><li>排版(优化阅读体验)</li><li>无内容减少</li></ul>]]></content>
    
    <summary type="html">
    
      软件构架、架构和框架的区别
    
    </summary>
    
      <category term="转载" scheme="https://sailhe.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="架构" scheme="https://sailhe.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript规范及其相关技术</title>
    <link href="https://sailhe.github.io/2019/06/02/ECMAScript%E8%A7%84%E8%8C%83%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    <id>https://sailhe.github.io/2019/06/02/ECMAScript规范及其相关技术/</id>
    <published>2019-06-02T13:25:51.000Z</published>
    <updated>2024-02-19T09:05:16.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="https://zh.wikipedia.org/zh-cn/ES6" target="_blank" rel="noopener">ES6</a>:<br> ECMAScript 2015（ES2015），第 6 版，最早被称作是 ECMAScript 6（ES6），添加了类和模块的语法，其他特性包括迭代器，Python风格的生成器和生成器表达式，箭头函数，二进制数据，静态类型数组，集合（maps，sets 和 weak maps），promise，reflection 和 proxies。作为最早的 ECMAScript Harmony 版本，也被叫做ES6 Harmony。 </p></blockquote><blockquote><p>在知道了ES6仍未实现之后，我始终暗示自己存在一种方法，使得可以避免使用ES5<br> 然后不停地寻找，最后发现这并不能实现，必须需要一个index之类的文件用于启动，而它必须只能是ES5的<br> 当然，它可以只有几条语句: 导入主方法，运行主方法，这之后只需要在主方法中使用ES6即可<br> 而ES6本身<strong>主要</strong>只是强化了类这一概念而已，然后就是模块的导入方法不同，当前的模块导入并非是官方实现的</p></blockquote><h2 id="CommonJS-Node-js"><a href="#CommonJS-Node-js" class="headerlink" title="CommonJS Node.js"></a><a href="www.commonjs.org/">CommonJS</a> Node.js</h2><p>如果是看过相关代码的话, 极有可能被这几个概念弄昏头, 此处直观地区分一下:</p><blockquote><ul><li>const, let 是ES5的内容<ul><li><strong>require</strong>是<strong>CommonJS</strong>的内容 <code>这一点下面会详细分析</code></li><li>CommonJS是<strong>Node.js</strong>平台的内容</li><li>Node.js使用chromium的<strong>V8引擎</strong></li></ul></li></ul></blockquote><p><a href="https://www.tuicool.com/articles/nueqi27" target="_blank" rel="noopener">关于AMD,CMD,CommonJS及UMD规范</a><br><a href="https://www.cnblogs.com/imwtr/p/4666181.html" target="_blank" rel="noopener">关于 CommonJS AMD CMD UMD 规范的差异总结</a></p><h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><p><code>引用原文</code><a href="https://www.zhihu.com/question/56820346" target="_blank" rel="noopener">模块导入 require，import的区别</a></p><blockquote><p>require/exports 出生在野生规范当中，什么叫做野生规范？即这些规范是 JavaScript 社区中的开发者自己草拟的规则，得到了大家的承认或者广泛的应用。比如 CommonJS、AMD、CMD 等等。<br>  import/export 则是名门正派。TC39 制定的新的 ECMAScript 版本，即 ES6（ES2015）中包含进来。<br>  <code>本人注: 不论前边多花哨, require里边以及from后边的引号是必须的, 该字符串实质上是一个路径(绝对/相对)</code><br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// require/exports 的用法只有以下三种简单的写法</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">exports.fs = fs</span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而 import/export 的写法就多种多样：import fs from 'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile <span class="keyword">as</span> read&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> fs, &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> </span>&#123;readFile, read&#125;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'fs'</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>_</p><ol><li>CommonJS 还是 ES6 Module 输出都可以看成是一个具备多个属性或者方法的对象；</li><li>default 是 ES6 Module 所独有的关键字，export default fs 输出默认的接口对象，import fs from ‘fs’ 可直接导入这个对象；<code>本人注: 一般情况下是需要解构赋值的</code></li><li>ES6 Module 中导入模块的属性或者方法是强绑定的，包括基础类型；而 CommonJS 则是普通的值传递或者引用传递。</li></ol></blockquote><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p><code>ES6</code>Point.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若在ES6中则按照ES6规范正常导入即可<br><code>ES6</code>Line.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import Point from Point; // 同样需要使用解构赋值</span></span><br><span class="line"><span class="comment">// import &#123;Point&#125; from Point; // 引号</span></span><br><span class="line"><span class="comment">// import &#123;Point&#125; from 'Point'; // 编译通过&amp;&amp;运行失败(Cannot find module 'Point') 是基于字符串查找实现的</span></span><br><span class="line"><span class="keyword">import</span> Point <span class="keyword">from</span> <span class="string">'./Point'</span>; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(xO, yO, xT, yT) &#123;</span><br><span class="line">      <span class="keyword">this</span>.origin = <span class="keyword">new</span> Point(xO, yO);</span><br><span class="line">      <span class="keyword">this</span>.target = <span class="keyword">new</span> Point(xT, yT);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    toString() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.origin.toString() + <span class="string">', '</span> + <span class="keyword">this</span>.target.toString() + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于上述第2点, 使用 require 导入 ES6 的 export 时 需要<br><code>ES5</code>index.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import Point from /lib/Point; // 此处并不能使用ES6(而且语法还错了)</span></span><br><span class="line"><span class="comment">// const Point = require("./lib/Point"); // 不使用解构赋值是不行的</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">若使用 export default class ClassName 但仍使用解构赋值的话</span></span><br><span class="line"><span class="comment">则 编译会通过, 但会在首次使用 new ClassName 的地方line[14]提示错误:</span></span><br><span class="line"><span class="comment">  TypeError: ClassName is not a constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> Point = <span class="built_in">require</span>(<span class="string">"./lib/Point"</span>).default; <span class="comment">// 引用babel编译后的ES5</span></span><br><span class="line"><span class="keyword">const</span> &#123;Line&#125; = <span class="built_in">require</span>(<span class="string">"./lib/Line"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> po = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> pt = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(po.toString());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Line(po.x, po.y, pt.x, pt.y).toString());</span><br></pre></td></tr></table></figure></p><p><code>参考-1</code><a href="https://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">ECMAScript 6 入门</a><br><code>参考-1</code><a href="https://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module 的语法</a><br><code>参考</code><a href="https://www.jianshu.com/p/edaf43e9384f" target="_blank" rel="noopener">ES6：export default 和 export 区别</a><br><code>参考</code><a href="https://segmentfault.com/a/1190000010426778" target="_blank" rel="noopener">exports、module.exports和export、export default到底是咋回事</a><br><code>参考, GK: {babel 编译 export default  使用require导入; exports.default require}</code><a href="https://juejin.im/post/5a2e5f0851882575d42f5609" target="_blank" rel="noopener">import、require、export、module.exports 混合使用详解</a></p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a><a href="https://www.babeljs.cn/docs/usage" target="_blank" rel="noopener">Babel</a></h2><p><code>参考-1</code><a href="https://es6.ruanyifeng.com/#docs/intro#Babel-%E8%BD%AC%E7%A0%81%E5%99%A8" target="_blank" rel="noopener">Babel-转码器</a></p><blockquote><p>Babel 是一个 JavaScript 编译器<br> Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p><ul><li>编译后的js代码使用严格模式可能是因为编译后的文件的名称可能会造成命名冲突</li></ul></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一句话, ES6并未实现, 是babel编译器将ES6编译为ES5, 所以当下必须使用一个引导, 此引导需使用ES5, 当然它可以引用<strong>编译后的ES5代码</strong></p><blockquote><p>注意, 若前后端都使用js的话极易引起混淆</p><ol><li>基于node.js的后端的js原本就可以导入导出模块, 只是想要使用ES6的话就得使用bable之类的编译器</li><li>{Vue, React, Angular, Backbone} 是<strong>前端框架</strong>, 目前<strong>前端</strong>的主体是 HTML5 和 CSS3, 当然 HTML和CSS只是<strong>最终目标</strong>, 而不是这些框架本身的实现</li><li>{swig} 是 <strong>HTML模板引擎</strong>, JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。并不是HTML模板</li><li>{acss} 是 <strong>CSS模板引擎</strong></li><li>前端框架<strong>一般</strong>包括默认的或允许自定义HTML和CSS的模板引擎, 这就是<strong>误解的源头</strong>, 在啥也不了解的时候, 可能会觉得前端框架就是那些引擎本身, 而框架实质上只是技术的组合</li><li>若想在前端写js的时候向node后端一样导入导出模块, 则需要引入<strong>第三方用于解决依赖的js插件</strong>, 可能还需要遵循一定的语法</li><li><a href="https://zh.wikipedia.org/wiki/React" target="_blank" rel="noopener">React</a>（有时叫React.js或ReactJS）是一个为数据提供渲染为HTML视图的开源<strong>JavaScript 库</strong>。</li><li><a href="https://zh.wikipedia.org/wiki/Vue.js" target="_blank" rel="noopener">Vue</a>Vue.js（/vjuː/，或简称为Vue）是一个用于创建用户界面的开源<strong>JavaScript框架</strong>，也是一个创建单页应用的Web应用框架。AngularJS 是 Vue 早期开发的灵感来源</li><li>在传统的WEB前端中, 工程师需要组合各种<strong>HTML标签</strong>来达到某种效果</li><li>在使用了React后, 这些标签可以组合起来, 形成一个<strong>组件</strong>, 利用HTML本身就可以使用js动态添加的特性, 进行所谓的<strong>渲染</strong>, 因此在 React 中，一切都是 JavaScript。<a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank" rel="noopener">前端框架的对比</a></li><li>Weex 是使用流行的 Web 开发体验来开发高性能原生应用的框架。<a href="https://weex.incubator.apache.org/zh/guide/introduction.html#概述" target="_blank" rel="noopener">官网概述</a>如是说 <code>不清楚是否更改+字都认识系列</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 为了更好地适应复杂的项目，Vue支持以.vue为扩展名的文件来定义一个完整组件，用以替代使用Vue.component注册组件的方式。开发者可以使用 Webpack或Browserify等构建工具来打包单文件组件。</span><br><span class="line">Vue.component(&apos;buttonclicked&apos;, &#123;</span><br><span class="line">  props: [</span><br><span class="line">    &apos;initial_count&apos;</span><br><span class="line">  ],</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &apos;&lt;button v-on:click=&quot;onclick&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times&lt;/button&gt;&apos;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onclick() &#123;</span><br><span class="line">      this.count += 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.count = this.initial_count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; render &#125; from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">class HelloMessage extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加载组件到 DOM 元素 mountNode</span><br><span class="line">render(&lt;HelloMessage name=&quot;John&quot; /&gt;, mountNode);</span><br></pre></td></tr></table></figure><ol start="11"><li><p><a href="https://zh.wikipedia.org/wiki/Webpack" target="_blank" rel="noopener">Webpack</a> 是一个开源的前端打包工具。<strong>Webpack 提供了前端开发缺乏的模块化开发方式</strong>，将各种静态资源视为模块，并从它生成优化过的代码。<br>以下引用自<a href="https://www.webpackjs.com/concepts/modules/" target="_blank" rel="noopener">原文</a></p><blockquote><p>什么是 webpack 模块<br>对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：<br>ES2015 <code>import</code> 语句<br>CommonJS <code>require()</code> 语句<br>AMD <code>define</code> 和 <code>require</code> 语句<br>css/sass/less 文件中的 @import 语句。<br>样式(<code>url(...)</code>)或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接(<code>image url</code>)</p></blockquote></li><li><p>也就是说, Webpack整合了包括之前介绍过模块导入方法在内的几乎所有方法, 并且, 为前端开发提供了模块化开发方式, 也就是说Tips[6]提到的第三方插件已经没有存在的必要了</p></li><li>上述所有一切都是为了<strong>解决依赖</strong></li><li>Webpack的原理大概就是分析所有依赖语句, 然后合成到一个文件中</li><li>由于HTML动态的部分也包含在JS里面了, 因此, 传统WEB中每个页面都包含的复杂HTML元素现在几乎就剩只有一个id为’root’的div了, 所有元素都是后期渲染上去的</li><li>Webpack与HTML模板的区别在于 前者是动态添加DOM元素, 类似于在页面引入一个js, js里边添加所有元素; 而后者是基于模板生成HTML, 类似于复用DOM; <strong>这两者都是静态页面</strong>;</li><li><strong>静态页面</strong>表示没有后端, 不是指没有动态(DOM元素的变化)</li><li><strong>动态页面</strong>的页面<strong>可以是</strong>在后端实时生成后返回给前端的</li></ol><p> 以下都依赖于Node.js, 这一基于MIT开源的<strong>跨平台JavaScript运行环境</strong></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">主要技术依赖</th><th style="text-align:center">解决的问题</th><th style="text-align:center">类型</th><th style="text-align:center">原作者+开发者</th><th style="text-align:left">语言</th><th>初版</th><th>许可协议</th></tr></thead><tbody><tr><td style="text-align:center">Webpack</td><td style="text-align:center">Node.js</td><td style="text-align:center">资源加载/模块化-解决依赖</td><td style="text-align:center">前端打包工具</td><td style="text-align:center">Tobias Koppers…</td><td style="text-align:left">JavaScript</td><td>2012年03月</td><td>MIT</td></tr><tr><td style="text-align:center">React</td><td style="text-align:center">Webpac; kJSX</td><td style="text-align:center">跨平台渲染数据为HTML视图</td><td style="text-align:center">前端渲染库</td><td style="text-align:center">Jordan Walke+Facebook+Instagram+社区</td><td style="text-align:left">JavaScript</td><td>2013年03月</td><td>MIT</td></tr><tr><td style="text-align:center">AngularJS</td><td style="text-align:center">Node.js</td><td style="text-align:center">协助单页Web应用程序运行</td><td style="text-align:center">前端库(MVC)</td><td style="text-align:center">Miško Hevery+Adam Abrons+Google+社区</td><td style="text-align:left">TypeScript</td><td>2010年10月</td><td>MIT</td></tr><tr><td style="text-align:center">Weex</td><td style="text-align:center">Webpack; Vue</td><td style="text-align:center">跨平台用户界面开发</td><td style="text-align:center">框架</td><td style="text-align:center">阿里巴巴发起+社区</td><td style="text-align:left">JavaScript</td><td>2016年–月</td><td>Apache</td></tr><tr><td style="text-align:center">Vue</td><td style="text-align:center">Node.js</td><td style="text-align:center">创建用户界面</td><td style="text-align:center">前端/单页Web应用框架</td><td style="text-align:center">Evan You</td><td style="text-align:left">JavaScript</td><td>2014年02月</td><td>MIT</td></tr><tr><td style="text-align:center">Electron</td><td style="text-align:center">Chromium</td><td style="text-align:center">桌面GUI应用程序开发</td><td style="text-align:center">软件框架</td><td style="text-align:center">GitHub</td><td style="text-align:left">多种</td><td>2013年7月</td><td>MIT</td></tr></tbody></table><blockquote><p>宏观概念的区别</p><pre><code>- **[库](https://zh.wikipedia.org/wiki/函式庫)**(Library )是用于开发软件的子程序集合。库和可执行文件的区别是，库不是独立程序，他们是向其他程序提供服务的代码。**工具集合**- **[框架](https://zh.wikipedia.org/wiki/軟體框架)**(Framework)通常指的是为了实现某个业界标准或完成特定基本任务的**软件组件规范**; 也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品, 此时功能类似于**基础设施**。- **[架构](https://zh.wikipedia.org/wiki/软件架构)**(Architecture)是有关**软件整体结构**与**组件**的抽象描述，用于指导大型软件系统各个方面的设计。不是[计算机系统结构](https://zh.wikipedia.org/wiki/计算机系统结构)- **[平台](https://zh.wikipedia.org/wiki/系统平台)**是指在计算机里让软件运行的**系统环境**，包括硬件环境和软件环境。是能做的最根本的几件事的集合, 加法-&gt;高数以下(减法可补码, 积分类加, 微分类减),微信-&gt;小程序; 浏览器-&gt;Web应用; JVM-&gt;Java程序</code></pre></blockquote><blockquote><p>不恰当的理解:<br><strong>函数</strong>的实现往往依赖于特定的<strong>数据结构</strong> (否则实现起来或比较繁琐)<br><strong>算法</strong>是函数的核心(业务逻辑算..吧)<br><strong>方法</strong>是仅用于操纵数据结构的<strong>内部数据</strong>的函数<br><strong>类</strong>是<strong>封装</strong>了方法的数据结构, 用方法体现<strong>行为</strong>, 用内部数据体现<strong>状态</strong><br>函数的集合 称库<br>库   的组合 称框架, 库之间通过<strong>接口</strong>连接</p></blockquote><p>编程方法学</p><table><thead><tr><th><a href="https://zh.wikipedia.org/wiki/编程范式" target="_blank" rel="noopener">编程范式</a></th><th>将程序视为</th><th>基础</th></tr></thead><tbody><tr><td><a href="https://zh.wikipedia.org/wiki/面向对象程序设计" target="_blank" rel="noopener">面向对象程序设计</a></td><td>相互作用的对象</td><td>{封装, 多态, 抽象, 继承}</td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/函数式编程" target="_blank" rel="noopener">函数式程序设计</a></td><td>函数计算的序列</td><td>{lambda运算, 闭包}</td></tr></tbody></table><blockquote><p>框架与库之间最本质区别在于控制权<br>you call libs (函数调用)<br>frameworks inject you (控制反转后的依赖注入)<br>React+Flux+react-router+react-redux 是 框架</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/Electron" target="_blank" rel="noopener">Electron</a>(原名为Atom Shell) 是GitHub开发的一个开源框架。<br>著名项目</p><ul><li>Github客户端</li><li>Atom</li><li>Visual Studio Code</li><li>MongoDB Compass</li><li><a href="https://zh.wikipedia.org/wiki/Unity_(游戏引擎" target="_blank" rel="noopener">Unity</a>)</li></ul><p>Repository<br><a href="https://github.com/electron/electron" target="_blank" rel="noopener">Electron</a><br><a href="https://github.com/facebook/react" target="_blank" rel="noopener">React</a><br>其它的就看Wiki好了..就不多列举了</p><h2 id="关于跨平台"><a href="#关于跨平台" class="headerlink" title="关于跨平台"></a>关于跨平台</h2><p>正因为Node.js本身是跨平台的, 这俩框架才有跨平台的可能, 但两者间并没有直接联系, Node.js跨平台直接决定了依赖于它的软件能够在不同的平台上构建(指Linux和Win)<br>指跨移动端{Android, iOS}和WEB, 而且是一次编写(只能算减少工作量)</p><ul><li>React Native(RN) 所有东西本就是JS</li><li>Weex是将 .vue ,  .we 文件编译成 JS</li><li><a href="https://zh.wikipedia.org/w/index.php?title=Special:%E6%90%9C%E7%B4%A2&amp;search=Weex&amp;ns0=1" target="_blank" rel="noopener">Weex</a>, apache, MYZ 了解一下</li><li>RN毕竟更成熟(时间上+网评+社区), 之前花了好久才编译出一个基于RN的App: <a href="https://github.com/BoostIO/boostnote-mobile" target="_blank" rel="noopener">BoostNote</a>, 效果却奇差无比, 估计试图开发完全跨平台的程序很难, 另外得提一下, <a href="https://github.com/BoostIO/Boostnote" target="_blank" rel="noopener">BoostNote</a> 好歹是正儿八经的跨平台呀, 不过之前做过测评, 最终没用这个, 个人认为其架构{electron; react}值得借鉴</li><li>某种意义上来说JS本身就是跨平台的(都有浏览器吧), 只是支持程度不同, 所以要搞兼容</li><li>Java也说过一次编写到处运行, 不过它靠的是JVM虚拟机</li></ul><p>组件化：webComponent; polymer; x-tag; react; jQuery-plugin; angular-directive<br>模块化:  webpack; browserify; require.js; sea.js<br>开发效率：MVC(Backbone) &lt; Flux(React) &lt; <a href="https://zh.wikipedia.org/zh-hans/MVVM" target="_blank" rel="noopener">MVVM</a>(Angular.js; vue; ember.js)<br>运行效率：Backbone; React<br>可维护性：Flux; Redux</p><p><a href="https://www.jianshu.com/p/132b6d171647" target="_blank" rel="noopener">webpack 解决的痛点</a><br><a href="https://www.gaoshilei.com/2017/05/26/weex-1/" target="_blank" rel="noopener">Weex从入门到超神（一）</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.cnblogs.com/ziyunfei/p/6038213.html" target="_blank" rel="noopener">用 const 还是用 let？</a></p>]]></content>
    
    <summary type="html">
    
      使用ES6, 实际上是混用ES5和ES6
    
    </summary>
    
      <category term="Experience" scheme="https://sailhe.github.io/categories/Experience/"/>
    
    
      <category term="Node.js" scheme="https://sailhe.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Javascript-解决_unreachable_code_after_return_statement_警告</title>
    <link href="https://sailhe.github.io/2019/05/31/Javascript-%E8%A7%A3%E5%86%B3_unreachable_code_after_return_statement_%E8%AD%A6%E5%91%8A/"/>
    <id>https://sailhe.github.io/2019/05/31/Javascript-解决_unreachable_code_after_return_statement_警告/</id>
    <published>2019-05-31T08:24:24.000Z</published>
    <updated>2024-02-19T06:38:57.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Main-Content"><a href="#Main-Content" class="headerlink" title="Main Content"></a>Main Content</h1><p><img src="/assets/img/sharding/err/instanceOf-old.png" alt="处理前"></p><p>此<a href="https://github.com/SailHe/lost_and_found/commit/4d438b403c6e64a9cdc5899095877a122c18ba15" target="_blank" rel="noopener">commit</a>修复了该潜在bug</p><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>大约就是写了这种代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br><span class="line">    <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>应该这么写:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/img/sharding/err/instanceOf-new.png" alt="处理后"></p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><ol><li>脚本代码执行以行为单位</li><li>js代码行末可以不用写’;’ -&gt; return 可以视为一条单独的语句</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Errors/Stmt_after_return?utm_source=mozilla&amp;utm_medium=firefox-console-errors&amp;utm_campaign=default" target="_blank" rel="noopener">MDN</a></li></ol>]]></content>
    
    <summary type="html">
    
      解决 unreachable code after return statement 警告
    
    </summary>
    
      <category term="Experience" scheme="https://sailhe.github.io/categories/Experience/"/>
    
    
      <category term="JacaScript" scheme="https://sailhe.github.io/tags/JacaScript/"/>
    
  </entry>
  
  <entry>
    <title>Markdown编辑器对比</title>
    <link href="https://sailhe.github.io/2019/05/31/Markdown%E7%BC%96%E8%BE%91%E5%99%A8%E5%AF%B9%E6%AF%94/"/>
    <id>https://sailhe.github.io/2019/05/31/Markdown编辑器对比/</id>
    <published>2019-05-31T08:24:24.000Z</published>
    <updated>2024-02-19T06:44:31.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Main-Content"><a href="#Main-Content" class="headerlink" title="Main Content"></a>Main Content</h1><p>可以参考这篇<a href="https://liutos.github.io/2018/12/14/用过的一些Markdown编辑器/" target="_blank" rel="noopener">Markdown编辑器评测</a>, 但其中并未提到VNote, 因此略作评测</p><h2 id="What-Require"><a href="#What-Require" class="headerlink" title="What-Require"></a>What-Require</h2><ol><li>经常编辑md文本</li><li>方便地打开和编辑Markdown文件(*.md)</li></ol><h2 id="How-Usage"><a href="#How-Usage" class="headerlink" title="How-Usage"></a>How-Usage</h2><p>用法-参考官方文档</p><h2 id="Why-Comparison"><a href="#Why-Comparison" class="headerlink" title="Why-Comparison"></a>Why-Comparison</h2><p>两个270行以上的文件+3个少于30行的小文件:</p><p><img src="/assets/img/sharding/boostnote.png" alt="两个270行以上的文件+3个少于30行的小文件"></p><p>一个270行以上的文件:</p><p><img src="/assets/img/sharding/vnote.png" alt="一个270行以上的文件"></p><p>两个文件一个270行一个10行不到:</p><p><img src="/assets/20190531175859679_31067.png" alt="两个文件一个270行一个10行不到"></p><ol><li>后者显然更占内存, 实际情况是在打开15个文件的时候占到了800M, 后者主打的Vim快捷键在前者的设置里面可以设置快捷键模式(但没有实际体验过, 应该不及后者)</li><li>但前者最大的缺点是不能直接编辑md文件(使用cjson文件), 需要导出, 不具备通用性</li><li>由于后者的官方并未发布Android平台的版本, 只能自行编译, 但表现极差, 极容易崩溃, 甚至可以说几乎不能使用, 还是尝试了好多次才进入主界面的, 关键是功能相差太大</li><li>后者的粘贴链接自动请求标题的功能很好用</li><li>后者更好看, PC版功能也很强, 但更像是一款笔记管理软件, 而非MarkDown编辑器</li><li>Vnote的图片粘贴功能做的也还中规中矩, 但始终感觉文件夹自定义功能很鸡肋, 作为笔记管理软件, 使用绝对目录没啥问题, 但作为编辑器的体验并不好</li></ol><p><a href="http://tinylab.org/markdown-lab/" target="_blank" rel="noopener">基于 Docker 的 Markdown 文档编辑环境</a><br><a href="https://github.com/mindmup/bootstrap-wysiwyg" target="_blank" rel="noopener">轻量级bootstrap兼容的WISWYG富文本编辑器</a></p><p><a href="https://zh.wikipedia.org/wiki/Typora" target="_blank" rel="noopener">typora</a>一个支持 Markdown 语言的文本编辑器, 适用于OS X、Windows和Linux三种操作系统，是一款免费软件。</p>]]></content>
    
    <summary type="html">
    
      对比常见Markdown编辑器
    
    </summary>
    
      <category term="Evaluation" scheme="https://sailhe.github.io/categories/Evaluation/"/>
    
    
      <category term="软件" scheme="https://sailhe.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Editor" scheme="https://sailhe.github.io/tags/Editor/"/>
    
      <category term="Markdown" scheme="https://sailhe.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>正确认识有关操作系统的几个重要概念</title>
    <link href="https://sailhe.github.io/2019/05/20/%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86%E6%9C%89%E5%85%B3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5/"/>
    <id>https://sailhe.github.io/2019/05/20/正确认识有关操作系统的几个重要概念/</id>
    <published>2019-05-20T13:11:31.000Z</published>
    <updated>2024-02-19T07:54:07.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念简介"><a href="#基本概念简介" class="headerlink" title="基本概念简介:"></a>基本概念简介:</h1><h2 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a><a href="/2018/12/20/正确认识操作系统进程/">前导知识</a></h2><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台:"></a>控制台:</h2><blockquote><p>即[命令行界面] (英语：command-line interface，缩写：CLI)<br> 也有人称之为[字符用户界面] (character user interface, CUI)</p></blockquote><pre><code>    是在[图形用户界面]得到普及之前使用最为广泛的用户界面，    通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。    用于提供丰富的控制与自动化的系统管理能力例如 Linux系统的Bash或是Windows系统的Windows PowerShell。</code></pre><h2 id="DOS系统"><a href="#DOS系统" class="headerlink" title="DOS系统:"></a><a href="https://zh.wikipedia.org/wiki/DOS" target="_blank" rel="noopener">DOS系统</a>:</h2><blockquote><p>磁盘操作系统(Disk Operating System, DOS): 是个人计算机上的一类操作系统。</p></blockquote><pre><code>透过批处理文件（扩展名为.BAT）提供界面脚本的功能。所有的DOS均使用命令行界面。运行程序的方法是在命令行中键入程序的名称。DOS系统包含一些公用程序，也提供了一些不是以程序方式存在的命令（常称为内部命令）</code></pre><h2 id="壳层-Shell"><a href="#壳层-Shell" class="headerlink" title="壳层(Shell)"></a>壳层(Shell)</h2><p><a href="https://zh.wikipedia.org/wiki/命令提示字元" target="_blank" rel="noopener">命令提示字元-Wiki</a></p><p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmd" target="_blank" rel="noopener">CMD官方文档</a></p><p><a href="https://zh.wikipedia.org/wiki/Windows_PowerShell" target="_blank" rel="noopener">Powershell-Wiki</a></p><p><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/understanding-important-powershell-concepts?view=powershell-6" target="_blank" rel="noopener">Powershell官方文档</a></p><p><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands" target="_blank" rel="noopener">Win-commands官方文档</a></p><blockquote><p>指”为用户提供用户界面”的软件，通常指的是命令行界面的解析器。<br>    一般来说，这个词是指操作系统中提供访问内核所提供之服务的程序。</p></blockquote><blockquote><p>Shell也用于泛指所有为用户提供操作界面的程序，也就是程序和用户交互的接口。<br>    因此与之相对的是内核（英语：Kernel），内核不提供和用户的交互功能。</p></blockquote><blockquote><p>不过这个词也拿来指应用软件，或是任何在特定组件外围的软件，例如浏览器或电子邮件软件是HTML排版引擎的shell。<br> Shell这个词是来自于操作系统（内核）与用户界面的外层界面。</p></blockquote><pre><code>管道:     管道(|), 是Shell的重要概念, EG: 将dir命令的输出定向到find命令 dir c:\ /s /b | find &quot;CPU&quot;    dir | findstr &quot;tmp&quot; 这使得findstr可以对文件夹信息进行搜索    命令大全(通过命名方式可知 这些命令, 例如netstat应该是一些程序或是脚本, 不是Powershell的语言本身)通常分类:    命令行壳层: 提供命令行界面(CLI 英文 Command Line Interface for batch scripting);        Windows操作系统-&gt;Windows 95 / 98下的command.com、Windows NT内核下的cmd.exe以及PowerShell            命令解释程序(command interpreter) Cmd.exe                命令行(Command-Line)                脚本拓展名: *.cmd            Powershell                不仅仅是Shell, 由于以.NET Framework技术为基础, 可以视作是一门脚本语言                脚本拓展名: *.ps1    图形壳层: 提供图形用户界面(GUI);        Windows操作系统-&gt;explorer.exe(俗称文件浏览器)</code></pre><h2 id="终端-terminal"><a href="#终端-terminal" class="headerlink" title="终端(terminal)"></a>终端(terminal)</h2><blockquote><p>是一台计算机或者计算机系统，用来让用户输入数据，及显示其计算结果的机器。<br>Virtual-Terminal<br>Hardware-Terminal</p></blockquote><hr><h2 id="常见cmd命令"><a href="#常见cmd命令" class="headerlink" title="常见cmd命令"></a>常见cmd命令</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:: 注释符(PS: 命令中的字母一般无大小写之分但符号必须一定为英文下打的)</span><br><span class="line"><span class="built_in">dir</span> :: 显示当前目录下文件(Alias: ls 但在<span class="built_in">CMD</span>下不可用)</span><br><span class="line"><span class="built_in">cd</span>\... :: 回到驱动器目录?</span><br><span class="line"><span class="function">d: :: 切换驱动器盘符(并不切换路径), <span class="title">Powershell</span>的<span class="title">cd</span>能够直接切换盘符, <span class="title">CMD</span>中切换盘符和切换目录是两码事</span></span><br><span class="line"><span class="function"><span class="title">cd</span> <span class="title">h</span>:\<span class="title">java</span> ::进入<span class="title">H</span>盘下的<span class="title">java</span>目录</span></span><br><span class="line"><span class="function"><span class="title">at</span> 12:00 <span class="title">filePath</span> :: 表示在12:00打开<span class="title">filePath</span>对应的文件(现已弃用)</span></span><br><span class="line"><span class="function"><span class="title">start</span> ::(当前命令提示符窗口中打开新的命令提示符窗口)</span></span><br></pre></td></tr></table></figure><pre><code>显示活动的TCP连接，计算机正在侦听的端口，以太网统计信息，IP路由表，IPv4统计信息(用于IP，ICMP，TCP和UDP协议)和IPv6统计信息(用于IPv6，ICMPv6，TCP over IPv6)和IPv6 over IPv6协议:</code></pre><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|<span class="built_in">findstr</span> "端口" :: 可以不用引号 指定端口没有被占用则没有返回</span><br><span class="line">tasklist|<span class="built_in">findstr</span> "PID" :: 也可以在任务管理器的详情信息根据PID查询</span><br><span class="line"><span class="built_in">taskkill</span> /f /t /im 占用进程名.exe :: 杀死服务以释放被占用的端口</span><br></pre></td></tr></table></figure><p><code>超酷炫的Blog</code><a href="https://xstarcd.github.io/wiki/windows/windows_cmd_syntax.html" target="_blank" rel="noopener">windows CMD命令大全及详细解释和语法</a></p><p><strong>以下源于中文网络, 或不可靠, 最好参考MS官方文档, 若没有中文版本, 实机上的帮助文档可能有中文</strong><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command /? :: 输出command命令的帮助文档</span><br></pre></td></tr></table></figure></p><blockquote><p>P1<br>　　winver———检查Windows版本<br>　　wmimgmt.msc—-打开windows管理体系结构(WMI)<br>　　wupdmgr——–windows更新程序<br>　　wscript——–windows脚本宿主设置<br>　　write———-写字板<br>　　winmsd———系统信息<br>　　wiaacmgr——-扫描仪和照相机向导<br>　　winchat——–XP自带局域网聊天<br>P2<br>　　mem.exe——–显示内存使用情况<br>　　Msconfig.exe—系统配置实用程序<br>　　mplayer2——-简易widnows media player<br>　　mspaint——–画图板<br>　　mstsc———-远程桌面连接<br>　　mplayer2——-媒体播放机<br>　　magnify——–放大镜实用程序<br>　　mmc————打开控制台<br>　　mobsync——–同步命令<br>P3<br>　　dxdiag———检查DirectX信息<br>　　drwtsn32—— 系统医生<br>　　devmgmt.msc— 设备管理器<br>　　dfrg.msc——-磁盘碎片整理程序<br>　　diskmgmt.msc—磁盘管理实用程序<br>　　dcomcnfg——-打开系统组件服务<br>　　ddeshare——-打开DDE共享设置<br>　　dvdplay——–DVD播放器<br>P4<br>　　net stop messenger—–停止信使服务<br>　　net start messenger—-开始信使服务<br>　　notepad——–打开记事本<br>　　nslookup——-网络管理的工具向导<br>　　ntbackup——-系统备份和还原<br>　　narrator——-屏幕“讲述人”<br>　　ntmsmgr.msc—-移动存储管理器<br>　　ntmsoprq.msc—移动存储管理员操作请求<br>　　netstat -an—-(TC)命令检查接口<br>P5<br>　　syncapp——–创建一个公文包<br>　　sysedit——–系统配置编辑器<br>　　sigverif——-文件签名验证程序<br>　　sndrec32——-录音机<br>　　shrpubw——–创建共享文件夹<br>　　secpol.msc—–本地安全策略<br>　　syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码<br>　　services.msc—本地服务设置<br>　　Sndvol32——-音量控制程序<br>　　sfc.exe——–系统文件检查器<br>　　sfc /scannow—windows文件保护<br>P6<br>　　tsshutdn——-60秒倒计时关机命令<br>　　tourstart——xp简介（安装完成后出现的漫游xp程序）<br>　　taskmgr——–任务管理器<br>　　eventvwr——-事件查看器<br>　　eudcedit——-造字程序<br>　　explorer——-打开资源管理器<br>　　packager——-对象包装程序<br>　　perfmon.msc—-计算机性能监测程序<br>　　progman——–程序管理器<br>　　regedit.exe—-注册表<br>　　rsop.msc——-组策略结果集<br>　　regedt32——-注册表编辑器<br>　　rononce -p —-15秒关机<br>　　regsvr32 /u *.dll—-停止dll文件运行<br>　　regsvr32 /u zipfldr.dll——取消ZIP支持<br>P7<br>　　cmd.exe——–CMD命令提示符<br>　　chkdsk.exe—–Chkdsk磁盘检查<br>　　certmgr.msc—-证书管理实用程序<br>　　calc———–启动计算器<br>　　charmap——–启动字符映射表<br>　　cliconfg——-SQL SERVER 客户端网络实用程序<br>　　Clipbrd——–剪贴板查看器<br>　　conf———–启动netmeeting<br>　　compmgmt.msc—计算机管理<br>　　cleanmgr——-垃圾整理<br>　　ciadv.msc——索引服务程序<br>　　osk————打开屏幕键盘<br>　　odbcad32——-ODBC数据源管理器<br>　　oobe/msoobe /a—-检查XP是否激活<br>　　lusrmgr.msc—-本机用户和组<br>　　logoff———注销命令<br>　　iexpress——-木马捆绑工具，系统自带<br>　　Nslookup——-IP地址侦测器<br>　　fsmgmt.msc—–共享文件夹管理器<br>　　utilman——–辅助工具管理器<br>　　gpedit.msc—–组策略</p></blockquote>]]></content>
    
    <summary type="html">
    
      操作系统中的一些易混淆概念
    
    </summary>
    
      <category term="Docs" scheme="https://sailhe.github.io/categories/Docs/"/>
    
    
      <category term="ESR" scheme="https://sailhe.github.io/tags/ESR/"/>
    
      <category term="Operating-System" scheme="https://sailhe.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>解决一个奇怪的Hexo部署错误</title>
    <link href="https://sailhe.github.io/2019/05/18/%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84Hexo%E9%83%A8%E7%BD%B2%E9%94%99%E8%AF%AF/"/>
    <id>https://sailhe.github.io/2019/05/18/解决一个奇怪的Hexo部署错误/</id>
    <published>2019-05-18T06:18:46.000Z</published>
    <updated>2024-02-19T07:25:13.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个尖括号导致部署错误"><a href="#两个尖括号导致部署错误" class="headerlink" title="两个尖括号导致部署错误"></a>两个尖括号导致部署错误</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (E:\Projects\Source\Repos\_blog\blog\node_modules\hexo-util\lib\spawn.js:52:19)</span><br><span class="line">    at emitTwo (events.js:126:13)</span><br><span class="line">    at ChildProcess.emit (events.js:214:7)</span><br><span class="line">    at ChildProcess.cp.emit (E:\Projects\Source\Repos\_blog\blog\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:198:12)</span><br></pre></td></tr></table></figure><ul><li>排查了挺长时间<strong>解决方案</strong>就一句话: 去除<code>_congif.yml</code>内<code>deploy</code>下<code>repo</code>内的尖括号(也有可能还会附带其它的冗余字符 比如空格什么的)</li></ul>]]></content>
    
    <summary type="html">
    
      解决一个奇怪的Hexo部署错误
    
    </summary>
    
      <category term="Experience" scheme="https://sailhe.github.io/categories/Experience/"/>
    
    
      <category term="Hexo" scheme="https://sailhe.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>初识shell编程</title>
    <link href="https://sailhe.github.io/2018/12/20/%E5%88%9D%E8%AF%86shell%E7%BC%96%E7%A8%8B/"/>
    <id>https://sailhe.github.io/2018/12/20/初识shell编程/</id>
    <published>2018-12-20T14:06:09.000Z</published>
    <updated>2024-02-19T07:51:23.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell-和-bash-的区别"><a href="#shell-和-bash-的区别" class="headerlink" title="shell 和 bash 的区别"></a>shell 和 bash 的区别</h1><p><a href="https://www.jianshu.com/p/a702a01db5c7" target="_blank" rel="noopener">简书参考</a><br>shell用于将命令翻译成计算机语言，也就是1和0,可以简单的将shell理解为命令行，与之相关的还有shell脚本，就是shell能识别的一连串命令行<br>bash是shell的一种.<br>  例如<br>    Bourne shell(sh); Linux中默认的shell就是Bourne-Again shell(简称bash)<br>    伯克利分校比尔▪乔伊写的C Shell(csh)，因为类似C语言，故此得名。</p><h1 id="关于如何使用win子系统安装Linux-以及zsh"><a href="#关于如何使用win子系统安装Linux-以及zsh" class="headerlink" title="关于如何使用win子系统安装Linux 以及zsh"></a>关于如何使用win子系统安装Linux 以及zsh</h1><p><a href="https://www.jianshu.com/p/bc38ed12da1d" target="_blank" rel="noopener">简书参考</a></p><p>zsh: 史称『终极 Shell』, 但配置复杂<br>–安装zsh 并更改默认shell<br><a href="https://www.jianshu.com/p/fe244b1c7737" target="_blank" rel="noopener">简书参考</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh -y</span><br><span class="line">chsh -s $(<span class="built_in">which</span> zsh)</span><br></pre></td></tr></table></figure></p><p>重启</p><p>–oh-my-zsh: zsh的配置项目<br><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">Github参考</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.zshrc ~/.zshrc.orig <span class="comment"># 若存在.zshrc则备份</span></span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc <span class="comment"># 创建模板.zshrc</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p><h1 id="Ubuntu-cmd"><a href="#Ubuntu-cmd" class="headerlink" title="Ubuntu cmd"></a>Ubuntu cmd</h1><p>Windows：先分区，再格式化。<br>Linux：一切皆文件。<br>挂载：将分区和目录绑定在一起。</p><p>pwd：打印当前工作目录。<br>mkdir：创建文件夹。<br>ls：列出所有子目录以及文件夹。<br>cd：改变当前工作目录。<br>tab快捷键：补全目录或者命令。<br>gedit ARM.c：新建ARM.c文件。<br>gedit spl.c &amp;：一边编辑文件，一边编译文件，不占用终端，文件在后台运行。<br>rm：删除文件。<br>rmdir：删除目录。<br>rm -rf hsp/: 强制删除文件目录以及下面包含的文件，强制递归删除。<br>mv main.c test.c: 文件重命名：(移动文件)<br>cp main.c hsp/main.c: 文件复制。<br>ps -aux：显示系统正在运行的程序。<br>pstree：树形显示系统中运行的程序。</p><p>kill -9  -3747：杀掉父进程。<br>shutdown -h now：立即关机<br>sudo shutdown -h now：切换到root用户再关机。<br>sudo root：重启。</p><p>sudo mv former_name new_name: 修改文件名<br>sudo mv former_name/ new_name/: 修改文件夹名</p><h1 id="Docker-in-Win10"><a href="#Docker-in-Win10" class="headerlink" title="Docker in Win10"></a>Docker in Win10</h1><p><a href="https://yeasy.gitbooks.io/docker_practice/image/pull.html" target="_blank" rel="noopener">书籍</a><br><a href="https://cloud.docker.com/" target="_blank" rel="noopener">下载</a><br><a href="https://blog.csdn.net/zhang197093/article/details/78643708" target="_blank" rel="noopener">CSDN</a></p><p>由于Docker是运行在linux系统上的，所以要想在windows上运行docker，需要借助虚拟机，老的<a href="https://www.docker.com/products/docker-toolbox" target="_blank" rel="noopener">Docker Toolbox</a>使用Oracle VM VirtualBox 来运行一个简化的linux系统，而目前的<a href="https://store.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener">Docker CE for Windows</a>则是使用微软自带的 Hyper-V（从Win8开始）虚拟机组件。</p><p>所以在安装Docker CE for Windows时，会帮你打开Hyper-V组件（默认是关闭的），这会和你的VirtualBox冲突，导致VirtualBox无法正常运行，解决办法就是关闭Hyper-V功能（卸载Docker CE for Windows时并不会自动帮你关闭）</p><ul><li><p>坑点1<br>类似的错误, 大可能是由于你使用了不在已有镜像服务器的镜像: 此时需要添加合适的镜像服务器, 或是换一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get https://registry-1.docker.io/v2/: net/http: request canceled while waiting for connection</span><br><span class="line">(Client.Timeout exceeded while awaiting headers)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://my.oschina.net/ykbj/blog/1595328" target="_blank" rel="noopener">Docker 进阶</a></p></li><li><a href="https://archerwq.github.io/2017/09/21/setup-jekyll-locally-with-docker/" target="_blank" rel="noopener">使用Docker本地运行jekyll</a>(老版本 失败告终)</li><li><a href="https://annatarhe.github.io/2016/11/27/all-i-know-about-docker.html" target="_blank" rel="noopener">使用Docker本地运行jekyll</a>(老版本 折腾了至少一小时 运行起来了 但自己的博客并没有运行起来)</li><li><p><a href="https://docs.docker.com/docker-for-windows/#docker-settings-dialog" target="_blank" rel="noopener">官网Doc</a>(扣由桌面程序处启动)</p></li><li><p><a href="https://blog.csdn.net/u013948858/article/details/80811986" target="_blank" rel="noopener">更改镜像存储目录</a></p></li><li><a href="https://juejin.im/post/59a8f9e0f265da24797b7da0" target="_blank" rel="noopener">安装软件失败</a></li><li><a href="https://forums.docker.com/t/where-are-images-stored/9794/10" target="_blank" rel="noopener">更改WSL 或者 Docker的位置</a></li><li><p><a href="https://www.oschina.net/question/1050447_165040" target="_blank" rel="noopener">无名镜像</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; none &gt;</span><br></pre></td></tr></table></figure></li><li><p>简单解释</p></li></ul><ol><li>dockerfile: 构建镜像；服务除了可以基于指定的镜像，还可以基于一份 Dockerfile</li><li>docker run: 启动容器；</li><li>docker-compose: <a href="https://www.jianshu.com/p/2217cfed29d7" target="_blank" rel="noopener">启动服务</a>；</li></ol><ul><li>PS<br>之前把 system 拼成了 systme, Google翻译也能显示出系统的译文(但并不详细), 人工ZZ诶</li></ul><ul><li>Github Gist 2018年12月左右</li><li>更新: 2019-05-19 22:06:09</li></ul><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#uninstall-old-versions" target="_blank" rel="noopener">Get Docker Engine - Community for Ubuntu</a></p>]]></content>
    
    <summary type="html">
    
      归纳整理操作系统相关的知识与文档
    
    </summary>
    
      <category term="Induction" scheme="https://sailhe.github.io/categories/Induction/"/>
    
    
      <category term="ESR" scheme="https://sailhe.github.io/tags/ESR/"/>
    
      <category term="Operating-System" scheme="https://sailhe.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>正确认识操作系统进程</title>
    <link href="https://sailhe.github.io/2018/12/20/%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/"/>
    <id>https://sailhe.github.io/2018/12/20/正确认识操作系统进程/</id>
    <published>2018-12-20T14:06:09.000Z</published>
    <updated>2024-02-19T07:54:33.733Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zh.wikipedia.org/wiki/行程" target="_blank" rel="noopener">进程</a>（英语：process），是指计算机中已运行的程序。<br>进程为曾经是分时系统的基本运作单位。<br>在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；<br><strong>在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。</strong><br><strong>程序</strong>本身只是指令、数据及其组织形式的描述，<strong>进程</strong>才是程序（那些指令和数据）的真正运行实例。<br>若干进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。<br>现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。<br>同样的，使用<strong>多线程</strong>技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机体系结构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不&gt;同的CPU上）。</p></blockquote><blockquote><p><a href="https://zh.wikipedia.org/wiki/线程" target="_blank" rel="noopener">线程</a>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。<br><strong>一条线程</strong>指的是进程中一个单一顺序的控制流，一个进程中可以<strong>并发</strong>多个线程，每条线程并行执行不同的任务。<br>在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。<br>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；<br>由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。<br>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。<br>但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p></blockquote><p>区分</p><ul><li>程序: 指令、数据及其组织形式的描述。</li><li>进程: 是程序的运行实例。<br><img src="/assets/opsystem/blog本地运行时的进程.png" alt="Hexo blog 服务启动后创建的进程"></li><li>线程: 是进程中的实际运作单位。<br><img src="/assets/opsystem/程序运行时的线程.png" alt="正在运行的某程序的线程"></li><li><strong>并发</strong>: 同一个<strong>时间段</strong>存在多个正在运行的线程，且都在同一个处理机上运行，但任一个时刻点上只有一个线程在处理机上运行。</li><li><strong>并行</strong>: 同一个<strong>时刻</strong>存在多个正在运行的进程。</li></ul><p>一个进程可以有很多线程，每条线程并行执行不同的任务。</p><blockquote><p><strong>并发</strong>: 当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段&gt;的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。<br><strong>并行</strong>：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为&gt;并行(Parallel)。<br>区别：并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。<br>在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。<br>倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。<br><a href="http://term.ccf.org.cn/index.php/并发" target="_blank" rel="noopener">参考</a></p></blockquote><p><img src="/assets/opsystem/操作系统基本概念-概览.png" alt="操作系统基本概念-概览"></p><p><img src="/assets/opsystem/进程.png" alt="进程"></p><p><img src="/assets/opsystem/CPU.png" alt="CPU"></p><ul><li>Github Gist 2018年12月左右</li><li>更新: 2019-05-19 22:06:09</li></ul>]]></content>
    
    <summary type="html">
    
      归纳整理操作系统相关的知识与文档
    
    </summary>
    
      <category term="Induction" scheme="https://sailhe.github.io/categories/Induction/"/>
    
    
      <category term="ESR" scheme="https://sailhe.github.io/tags/ESR/"/>
    
      <category term="Operating-System" scheme="https://sailhe.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>混合编程-关于区间参数的最佳实践</title>
    <link href="https://sailhe.github.io/2018/12/18/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B-%E5%85%B3%E4%BA%8E%E5%8C%BA%E9%97%B4%E5%8F%82%E6%95%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://sailhe.github.io/2018/12/18/混合编程-关于区间参数的最佳实践/</id>
    <published>2018-12-18T12:38:57.000Z</published>
    <updated>2024-02-19T05:49:01.272Z</updated>
    
    <content type="html"><![CDATA[<p>若想写出便于移植的代码, 对于常见语言的容器或类来说, 这几门语言之间的共同点是什么; 问题的最佳实践又是什么</p><p>浮点数实现上的差异(略).</p><p>如果是传入一个区间, 是否都是左闭右开</p><ol><li><code>2022-12-25 22:02 验证</code> 这一点得到了相对广泛的验证, 各大主流语言(包括C/C++, java, js, python)皆是如此</li><li>另外, 值得一提的是, 人类语言中普遍是左闭右闭区间, 可以视为是一个约定了</li></ol><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>当服务器被告知监听时0.0.0.0，意味着“监听每个可用的网络接口”。<br>127.0.0.1从服务器进程的角度看，具有IP地址的环回适配器看起来就像机器上的任何其他网络适配器一样，因此被告知监听的服务器0.0.0.0也将接受该接口上的连接。</p><ul><li>Github Gist 2018年12月左右</li><li>更新: 2019-05-19 20:38:57</li></ul>]]></content>
    
    <summary type="html">
    
      混合编程时关于区间参数的最佳实践
    
    </summary>
    
      <category term="Induction" scheme="https://sailhe.github.io/categories/Induction/"/>
    
    
      <category term="ESR" scheme="https://sailhe.github.io/tags/ESR/"/>
    
      <category term="Pits" scheme="https://sailhe.github.io/tags/Pits/"/>
    
      <category term="混合编程" scheme="https://sailhe.github.io/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>混合编程-类似函数区分</title>
    <link href="https://sailhe.github.io/2018/12/17/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B-%E7%B1%BB%E4%BC%BC%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%86/"/>
    <id>https://sailhe.github.io/2018/12/17/混合编程-类似函数区分/</id>
    <published>2018-12-17T12:38:57.000Z</published>
    <updated>2024-02-19T05:48:43.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类似函数区分"><a href="#类似函数区分" class="headerlink" title="类似函数区分"></a>类似函数区分</h1><h2 id="按照函数功能说明"><a href="#按照函数功能说明" class="headerlink" title="按照函数功能说明"></a>按照函数功能说明</h2><ol><li>针对字符串对象(一般)<br>分离分割(split):  按字符, 按字串分割<br>合并连接(concat): 一般等价于+运算符<br>部分切片(slice): 返回新子串</li><li>针对数组对象(一般)<br>人工拼接(splice): splice(start[, deleteCount[, item1[, item2[, …]]]])<br>   通过[删除]现有元素 和/或 [添加新]元素来[修改]数组,并以数组[返回]原数组中[被修改的内容。</li></ol><h2 id="按照语言说明"><a href="#按照语言说明" class="headerlink" title="按照语言说明"></a>按照语言说明</h2><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>(lambda表达式)实际场景是react js同理</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a></li></ol><p>onSuccess={(res, file, data) =&gt; ({ data })}<br>onSuccess={(res, file, data) =&gt; data}<br>前者后后者不等价<br>但都表示onSuccess是一个函数对象(js使用时需去掉最外层的花括号)<br>前者onSuccess(null, null, 123)<br>{data: 123}</p><p>后者onSuccess(null, null, 123)<br>123</p><h3 id="按方法名称说明"><a href="#按方法名称说明" class="headerlink" title="按方法名称说明"></a>按方法名称说明</h3><p>blind : 貌似是bind的误拼<br>on : $<br>bind : $ DOM<br>call : DOM<br>apply : DOM</p><p>在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。<br>JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。<br><a href="web.jobbole.com/83642/">出处</a></p><ol><li>Prototype(原型属性 Object对象的属性)<br>PS: 原型操作(设置对象的[[Prototype]])很缓慢建议避免</li><li>props : <a href="https://react.docschina.org/" target="_blank" rel="noopener">Rect</a> 中子组件用来向父组件传递数据的属性。<ul><li>有状态组件除了使用外部传入的数据以外 (通过 this.props 访问传入数据), 组件还可以拥有其内部的状态数据 (通过 this.state 访问状态数据)。</li><li>当组件的状态数据改变时， 组件会调用 render() 方法重新渲染。</li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener"><strong>proto</strong></a><ul><li>建议使用 Object.create()创建原型</li><li>Object.prototype.<strong>proto</strong>: 获取原型?  Object.getPrototypeOf() <a href="https://xxxgitone.github.io/2017/06/08/一篇文章看懂-proto-和prototype的关系及区别/" target="_blank" rel="noopener">出处</a></li></ul></li></ol><ul><li>Github Gist 2018年12月左右</li><li>更新: 2019-05-19 20:38:57</li></ul>]]></content>
    
    <summary type="html">
    
      混合编程时会遇见的类似函数
    
    </summary>
    
      <category term="Induction" scheme="https://sailhe.github.io/categories/Induction/"/>
    
    
      <category term="ESR" scheme="https://sailhe.github.io/tags/ESR/"/>
    
      <category term="Pits" scheme="https://sailhe.github.io/tags/Pits/"/>
    
      <category term="混合编程" scheme="https://sailhe.github.io/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>初探Git</title>
    <link href="https://sailhe.github.io/2018/12/15/%E5%88%9D%E6%8E%A2Git/"/>
    <id>https://sailhe.github.io/2018/12/15/初探Git/</id>
    <published>2018-12-15T12:33:46.000Z</published>
    <updated>2024-02-19T05:55:02.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="切换远程仓库地址"><a href="#切换远程仓库地址" class="headerlink" title="切换远程仓库地址"></a>切换远程仓库地址</h2><p>一、修改命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin url</span><br></pre></td></tr></table></figure></p><p>二、先删后加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:sheng/repo-name.git</span><br></pre></td></tr></table></figure></p><p>三、修改config文件<br>如果你的项目有加入版本控制的话, 在项目根目录下查看隐藏的.git文件夹直接修改config文件的git remote origin地址.</p><ul><li><a href="https://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">简明教程1</a></li><li><a href="https://www.kancloud.cn/thinkphp/github-tips/37896" target="_blank" rel="noopener">简明教程2</a></li><li><a href="https://docs.spongepowered.org/stable/zh-CN/contributing/howtogit.html" target="_blank" rel="noopener">进阶</a></li></ul><h1 id="Github的多人协作"><a href="#Github的多人协作" class="headerlink" title="Github的多人协作"></a><a href="https://gist.github.com/suziewong/4378619" target="_blank" rel="noopener">Github的多人协作</a></h1><h1 id="fork并且更新一个仓库"><a href="#fork并且更新一个仓库" class="headerlink" title="fork并且更新一个仓库"></a>fork并且更新一个仓库</h1><p><a href="https://www.cnblogs.com/wzyxidian/p/5520051.html" target="_blank" rel="noopener">原文</a><br>现在有这样一种情形：有一个叫做Joe的程序猿写了一个游戏程序，而你可能要去改进它。并且Joe将他的代码放在了GitHub仓库上。下面是你要做的事情：</p><blockquote><p>fork并且更新GitHub仓库 图表演示<br>    Fork他的仓库：这是GitHub操作，这个操作会复制Joe的仓库（包括文件，提交历史，issues，和其余一些东西）。<br>    复制后的仓库在你自己的GitHub帐号下。目前，你本地计算机对这个仓库没有任何操作。<br>    Clone你的仓库：这是Git操作。使用该操作让你发送”请给我发一份我仓库的复制文件”的命令给GitHub。<br>    现在这个仓库就会存储在你本地计算机上。<br>    更新某些文件：现在，你可以在任何程序或者环境下更新仓库里的文件。<br>    提交你的更改：这是Git操作。使用该操作让你发送”记录我的更改”的命令至GitHub。此操作只在你的本地计算机上完成。<br>    将你的更改push到你的GitHub仓库：这是Git操作。使用该操作让你发送”这是我的修改”的信息给GitHub。<br>    Push操作不会自动完成，所以直到你做了push操作，GitHub才知道你的提交。<br>    给Joe发送一个pull request：如果你认为Joe会接受你的修改，你就可以给他发送一个pull request。<br>    这是GitHub操作，使用此操作可以帮助你和Joe交流你的修改，并且询问Joe是否愿意接受你的”pull request”，当然，接不接受完全取决于他自己。<br>    如果Joe接受了你的pull request，他将把那些修改拉到自己的仓库。胜利！</p></blockquote><blockquote><p>同步一个fork<br>    Joe和其余贡献者已经对这个项目做了一些修改，而你将在他们的修改的基础上，还要再做一些修改。<br>    在你开始之前，你最好”同步你的fork”，以确保在最新的复制版本里工作。下面是你要做的：<br>    Alt text<br>    同步GitHub fork 图表示意图<br>    从Joe的仓库中取出那些变化的文件：这是Git操作，使用该命令让你可以从Joe的仓库获取最新的文件。<br>    将这些修改合并到你自己的仓库：这是Git操作，使用该命令使得那些修改更新到你的本地计算机（那些修改暂时存放在一个”分支”中）。<br>    记住：步骤1和2经常结合为一个命令使用，合并后的Git命令叫做”pull”。<br>    将那些修改更新推送到你的GitHub仓库（可选）：记住，你本地计算机不会自动更新你的GitHub仓库。<br>    所以，唯一更新GitHub仓库的办法就是将那些修改推送上去。你可以在步骤2完成后立即执行push，也可以等到你做了自己的一些修改，并已经本地提交后再执行推送操作。<br>    比较一下fork和同步工作流程的区别：当你最初fork一个仓库的时候，信息的流向是从Joe的仓库到你的仓库，然后再到你本地计算机。<br>    但是最初的过程之后，信息的流向是从Joe的仓库到你的本地计算机，之后再到你的仓库。</p></blockquote><ul><li>Github Gist 2018年12月左右</li><li>更新: 2019-05-19 20:33:46</li></ul>]]></content>
    
    <summary type="html">
    
      记录首次大范围使用Git后的心得体会
    
    </summary>
    
      <category term="Tutorial" scheme="https://sailhe.github.io/categories/Tutorial/"/>
    
    
      <category term="Git" scheme="https://sailhe.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>编程文档黄页</title>
    <link href="https://sailhe.github.io/2018/12/14/%E7%BC%96%E7%A8%8B%E6%96%87%E6%A1%A3%E9%BB%84%E9%A1%B5/"/>
    <id>https://sailhe.github.io/2018/12/14/编程文档黄页/</id>
    <published>2018-12-14T13:06:31.000Z</published>
    <updated>2024-02-19T05:58:05.261Z</updated>
    
    <content type="html"><![CDATA[<p>普遍带有搜索功能的在线图书, 方便做为文档查询</p><h1 id="GitBook"><a href="#GitBook" class="headerlink" title="GitBook"></a>GitBook</h1><ul><li>Linux</li></ul><ol><li><a href="https://linux.hellocode.name/" target="_blank" rel="noopener">PHPer 必知必会的 Linux 命令</a></li></ol><ul><li>springmvc</li></ul><ol><li><a href="https://skyline75489.github.io/Heart-First-JavaWeb/" target="_blank" rel="noopener">Heart First Java Web</a></li></ol><ul><li>Node.Js</li></ul><ol><li><a href="https://wohugb.gitbooks.io/npm/content/index.html" target="_blank" rel="noopener">NPM</a></li></ol><ul><li>React.js</li></ul><ol><li><a href="https://hulufei.gitbooks.io/react-tutorial/content/index.html" target="_blank" rel="noopener">React 入门教程</a></li><li><code>英文</code><a href="https://reactcommunity.org/react-modal/" target="_blank" rel="noopener">React-modal</a><ul><li><code>框架</code><a href="https://cn.redux.js.org/" target="_blank" rel="noopener">Redux 中文文档</a></li><li><code>框架</code><a href="https://umijs.org/zh/guide/" target="_blank" rel="noopener">UmiJS 指南</a></li></ul></li></ol><h1 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h1><h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p><code>3.6</code><a href="https://github.com/hibernate/hibernate-orm/releases/tag/3.6.10.Final" target="_blank" rel="noopener">hibernate-orm下载</a></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ol><li><a href="https://www.jianshu.com/p/42620a0a2c33" target="_blank" rel="noopener">Spring,Spring MVC及Spring Boot区别</a></li><li><a href="https://github.com/waylau/spring-5-book" target="_blank" rel="noopener">Spring 5 案例大全/《Spring 5 开发大全》示例源码</a></li><li><a href="https://wiki.jikexueyuan.com/project/spring/architecture.html" target="_blank" rel="noopener">极客学院</a></li><li>SpringBoot 中使用servlet :<br> <a href="https://www.jianshu.com/p/2e7a0cef7339" target="_blank" rel="noopener">简书</a><br> <a href="https://blog.csdn.net/catoop/article/details/50501686" target="_blank" rel="noopener">CSDN</a></li></ol><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><ol><li><a href="https://wiki.jikexueyuan.com/project/maven/project-templates.html" target="_blank" rel="noopener">工程模板</a></li></ol><h2 id="Node-js-相关"><a href="#Node-js-相关" class="headerlink" title="Node.js 相关"></a>Node.js 相关</h2><ol><li><a href="https://fraserxu.me/2014/08/26/react-state-basics/" target="_blank" rel="noopener">invalid</a></li><li><a href="https://react.docschina.org/docs/create-a-new-react-app.html" target="_blank" rel="noopener">官方文档</a></li><li><code>英文</code><a href="https://docs.npmjs.com/" target="_blank" rel="noopener">npm官方文档</a></li></ol><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p><a href="https://www.runoob.com/redis/redis-install.html" target="_blank" rel="noopener">菜鸟教程</a><br><a href="https://try.redis.io/" target="_blank" rel="noopener">在线尝试Redis</a></p><h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><p><a href="https://github.com/qianjiahao/MongoDB/wiki/MongoDB简介" target="_blank" rel="noopener">第三方教程</a><br><a href="https://www.bilibili.com/video/av13930686/?p=4" target="_blank" rel="noopener">快速入门视频教程</a></p><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><ol><li><a href="https://pages.github.com/" target="_blank" rel="noopener">官方教程</a></li></ol><ul><li>基于jekyll</li></ul><ol><li><code>老版</code><a href="https://www.jianshu.com/p/fabb01427203" target="_blank" rel="noopener">野生教程</a></li><li><a href="https://www.jianshu.com/p/50d97f32e558" target="_blank" rel="noopener">结构</a></li></ol><ul><li>评论</li></ul><ol><li><a href="https://wingjay.com/2017/06/08/rebuild-personal-blog/" target="_blank" rel="noopener">使用Github的 issue API 作为评论</a></li></ol><h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a><a href="https://zh.wikipedia.org/wiki/YAML" target="_blank" rel="noopener">YAML</a></h2><ol><li>*.yml</li></ol><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ol><li><a href="https://blog.csdn.net/icamera0/article/details/50843172" target="_blank" rel="noopener">图片处理机器各种术语</a></li><li><code>古老的 pybrain</code><a href="http://pybrain.org/docs/api/datasets/superviseddataset.html" target="_blank" rel="noopener">superviseddataset神经网络训练器</a></li><li><a href="https://www.bilibili.com/video/av15532370" target="_blank" rel="noopener">B站视频讲解教程</a></li><li><a href="https://eastlakeside.gitbooks.io/interpy-zh/content/" target="_blank" rel="noopener">Python 进阶</a></li><li><code>书籍</code><a href="https://www.pythondoc.com/pythontutorial3/appetite.html" target="_blank" rel="noopener">Python tutorial</a></li><li><code>书籍</code><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">Python3 Cookbook</a></li></ol><ul><li>Github Gist 2018年12月左右</li><li>更新: 2019-05-19 21:06:31</li></ul>]]></content>
    
    <summary type="html">
    
      编程文档黄页
    
    </summary>
    
      <category term="Induction" scheme="https://sailhe.github.io/categories/Induction/"/>
    
    
      <category term="ESR" scheme="https://sailhe.github.io/tags/ESR/"/>
    
      <category term="Collection" scheme="https://sailhe.github.io/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>混合编程-字符串二元操作</title>
    <link href="https://sailhe.github.io/2018/12/11/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C/"/>
    <id>https://sailhe.github.io/2018/12/11/混合编程-字符串二元操作/</id>
    <published>2018-12-11T12:38:57.000Z</published>
    <updated>2024-02-19T05:48:18.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="允许的字符串操作"><a href="#允许的字符串操作" class="headerlink" title="允许的字符串操作"></a>允许的字符串操作</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="noopener">Js-String</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>().split(char <span class="built_in">String</span>).match(正则).concat(建议用+替代)search(regexp).replace(subString 正则).substr(起点, 字符数 需兼容旧环境).substring(indexStart[, indexEnd]).slice(返回新子串).trim(删除两端的空白字符)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>   -     substr find insert  replace 没有直接提供字符串分割(split), 拼接(concat)方法 但后者等价于<span class="string">'+'</span>运算符</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String.join();</span><br><span class="line">java.lang.String().substring(下标).replace(<span class="keyword">char</span> String 正则).concat(str).split(正则).regionMatches(范围相等).matches(正则匹配regex);</span><br></pre></td></tr></table></figure><ul><li>Github Gist 2018年12月左右</li><li>更新: 2019-05-19 20:38:57</li></ul>]]></content>
    
    <summary type="html">
    
      不同语言中的二元字符串操作
    
    </summary>
    
      <category term="Induction" scheme="https://sailhe.github.io/categories/Induction/"/>
    
    
      <category term="ESR" scheme="https://sailhe.github.io/tags/ESR/"/>
    
      <category term="Pits" scheme="https://sailhe.github.io/tags/Pits/"/>
    
      <category term="同种功能不同语言系列" scheme="https://sailhe.github.io/tags/%E5%90%8C%E7%A7%8D%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97/"/>
    
      <category term="混合编程" scheme="https://sailhe.github.io/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
